<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>POTATO RPG</title>
  <!-- 1. ìŠ¤íƒ€ì¼ ì„¤ì • -->
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&display=swap');
    body{font-family:'Noto Sans KR',sans-serif;background-color:#0f172a;color:#fff;margin:0;padding:0}
    #loading-screen{position:fixed;top:0;left:0;width:100%;height:100%;background:#0f172a;display:flex;flex-direction:column;justify-content:center;align-items:center;z-index:9999}
    .loader{border:4px solid #f3f3f3;border-top:4px solid #3498db;border-radius:50%;width:40px;height:40px;animation:spin 2s linear infinite;margin-bottom:20px}
    @keyframes spin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}
  </style>

  <!-- 2. vConsole -->
  <script src="https://unpkg.com/vconsole@latest/dist/vconsole.min.js"></script><script>try{var vConsole=new VConsole()}catch(e){}</script>

  <!-- 3. í•„ìˆ˜ ë¼ì´ë¸ŒëŸ¬ë¦¬ -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
</head>
<body>
  <div id="loading-screen"><div class="loader"></div><h2 style="color:#60a5fa;">ë¡œë”© ì¤‘...</h2><div id="loading-msg" style="margin-top:10px;color:#94a3b8;font-size:12px;">ë°ì´í„° ì—°ê²° ì‹œë„ ì¤‘...</div></div>
  <div id="root"></div>

  <script type="text/babel">
    const {useState,useEffect,useRef}=React;

    // =================================================================================
    // [í•„ìˆ˜] êµ¬ê¸€ ì•± ìŠ¤í¬ë¦½íŠ¸(GAS) ì›¹ ì•± URLì„ ì•„ë˜ ë”°ì˜´í‘œ ì•ˆì— ë„£ì–´ì£¼ì„¸ìš”.
    // =================================================================================
    const GOOGLE_SCRIPT_URL="https://script.google.com/macros/s/AKfycbwvL_qsVVvaS45572soDLu8byVX70XA4FCKf8jPcXTz8pA6LJvdBWCZo4Y7zl07Dn45og/exec";

    // --- [ìˆ˜ì •ë¨] ê²Œì„ ë°¸ëŸ°ìŠ¤ ì„¤ì • ---
   // âœ… ìˆ˜ë ¨ì˜ ìˆ²(=ì¼ë°˜ í•„ë“œ) ë“œë¡­ë¥ : Unique 1%, Rare 30%, Common 30% (Legend/Myth ì—†ìŒ)
const RARITY_RATES = { Unique: 0.01, Rare: 0.30, Common: 0.30 };

// âœ… ì „ì„¤ì˜ ë˜ì „ ë“œë¡­ë¥ : Legend 0.1%, Unique 10%, Rare 40%, ë‚˜ë¨¸ì§€ ë“œë¡­ ì—†ìŒ (Myth ì—†ìŒ)
const LEGEND_DROP_RATES = { Legend: 0.001, Unique: 0.10, Rare: 0.40 };

// âœ… ì‹œë ¨ì˜ íƒ‘ ë“œë¡­ë¥ : Myth 0.01%, Legend 1%, Unique 30%, ë‚˜ë¨¸ì§€ ë“œë¡­ ì—†ìŒ
const TOWER_DROP_RATES  = { Myth: 0.0001, Legend: 0.01, Unique: 0.30 };

    const RARITY_COLORS={Common:"text-gray-500",Rare:"text-blue-500",Unique:"text-purple-500",Legend:"text-orange-500",Myth:"text-red-600 font-bold animate-pulse"};

    // 1. ê¸°ë³¸ ê³µê²©ë ¥ ë²”ìœ„ ë° 2. íŒë§¤ ê°€ê²© ìˆ˜ì •
    const ITEM_RANGES={Common:{min:10,max:50,price:100},Rare:{min:50,max:100,price:300},Unique:{min:100,max:200,price:1000},Legend:{min:500,max:1000,price:10000},Myth:{min:1000,max:3000,price:50000}};
    const ARMOR_BASE_HP={Common:50,Rare:100,Unique:500,Legend:1000,Myth:3000};

    const ENHANCE_RATES=[0.9,0.8,0.7,0.6,0.5,0.4,0.3,0.2,0.1,0.1];
    const FRAGMENT_DROP_RATE=0.3; // ì¼ë°˜ í•„ë“œ ì¡°ê° í™•ë¥  30%
    const STONE_DROP_RATE = 0.05; // âœ… ì‹œë ¨ì˜ íƒ‘ ê°•í™”ì„ ë“œë¡­ í™•ë¥  5%
    const BOSS_ENTRY_COST=10;

    const MOCK_QUESTIONS=[
      {id:9991,subject:"ì‹œìŠ¤í…œ",question:"ë°ì´í„° ì—°ê²°ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",options:["ìƒˆë¡œê³ ì¹¨","ê´€ë¦¬ì ë¬¸ì˜"],answer:0},
      {id:9992,subject:"ìˆ˜í•™",question:"1 + 1 = ?",options:["1","2","3","4"],answer:1},
      {id:9993,subject:"ë³´ìŠ¤",question:"ë³´ìŠ¤ ì „ìš© ë¬¸ì œ í…ŒìŠ¤íŠ¸: ì‚¬ê³¼ì˜ ìƒ‰ê¹”ì€?",options:["ë¹¨ê°•","íŒŒë‘"],answer:0},
    ];

    const firebaseConfig={apiKey:"AIzaSyDOzfbbafGWHHC2QbGXTsp67bop74O5RIM",authDomain:"potatp-rpg.firebaseapp.com",projectId:"potatp-rpg",storageBucket:"potatp-rpg.firebasestorage.app",messagingSenderId:"665096612054",appId:"1:665096612054:web:2252bc6f22adf1f1cf8177"};
    let isFirebaseOk=false; try{ if(typeof firebase!=="undefined"){ if(!firebase.apps.length) firebase.initializeApp(firebaseConfig); isFirebaseOk=true; } }catch(e){ console.error("Firebase Init Error",e); }
    const db=isFirebaseOk?firebase.firestore():null, auth=isFirebaseOk?firebase.auth():null, appId="educational-rpg-gsheet";


    const Icons={
      Sword:({size=20,className=""})=><svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><polyline points="14.5 17.5 3 6 3 3 6 3 17.5 14.5"/><line x1="13" x2="19" y1="19" y2="13"/><line x1="16" x2="20" y1="16" y2="20"/><line x1="19" x2="21" y1="21" y2="19"/></svg>,
      Shield:({size=20,className=""})=><svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/></svg>,
      Heart:({size=20,className=""})=><svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M19 14c1.49-1.46 3-3.21 3-5.5A5.5 5.5 0 0 0 16.5 3c-1.76 0-3 .5-4.5 2-1.5-1.5-2.74-2-4.5-2A5.5 5.5 0 0 0 2 8.5c0 2.3 1.5 4.05 3 5.5l7 7Z"/></svg>,
      Coins:({size=20,className=""})=><svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><circle cx="8" cy="8" r="6"/><path d="M18.09 10.37A6 6 0 1 1 10.34 18"/><path d="M7 6h1v4"/><path d="m16.71 13.88.7.71-2.82 2.82"/></svg>,
      Skull:({size=20,className=""})=><svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><circle cx="9" cy="12" r="1"/><circle cx="15" cy="12" r="1"/><path d="M8 20v2h8v-2"/><path d="m12.5 17-.5-1-.5 1h1z"/><path d="M16 20a2 2 0 0 0 1.56-3.25 8 8 0 1 0-11.12 0A2 2 0 0 0 8 20"/></svg>,
      Hammer:({size=20,className=""})=><svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="m15 12-8.5 8.5c-.83.83-2.17.83-3 0 0 0 0 0 0 0a2.12 2.12 0 0 1 0-3L12 9"/><path d="M17.64 15 22 10.64"/><path d="m20.91 11.7-1.25-1.25c-.6-.6-.93-1.4-.93-2.25V2.46V2a2 2 0 0 0-2-2h-3a2 2 0 0 0-2 2v2.46c0 .85-.33 1.65-.93 2.25L11.7 10.91"/></svg>,
      LogOut:({size=20,className=""})=><svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"/><polyline points="16 17 21 12 16 7"/><line x1="21" x2="9" y1="12" y2="12"/></svg>,
      BookOpen:({size=20,className=""})=><svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"/><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"/></svg>,
      Lightbulb:({size=20,className=""})=><svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M15 14c.2-1 .7-1.7 1.5-2.5 1-1 1.5-2 1.5-3.5 0-3.3-2.7-6-6-6s-6 2.7-6 6c0 1.5.5 2.5 1.5 3.5.8.8 1.3 1.5 1.5 2.5"/><path d="M9 18h6"/><path d="M10 22h4"/></svg>,
      Menu:({size=20,className=""})=><svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><line x1="4" x2="20" y1="12" y2="12"/><line x1="4" x2="20" y1="6" y2="6"/><line x1="4" x2="20" y1="18" y2="18"/></svg>,
      RefreshCw:({size=20,className=""})=><svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"/><path d="M21 3v5h-5"/><path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"/><path d="M8 16H3v5"/></svg>,
      Puzzle:({size=20,className=""})=><svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M19.439 15.424a1 1 0 0 0-1.045 1.576 4.966 4.966 0 0 0-1.894 1.894 1 1 0 0 0 1.576 1.045l-3.237 3.237a.998.998 0 0 0 0 1.414l5.656-5.656a.998.998 0 0 0 0-1.414l-3.237-3.237a1 1 0 0 0 1.576-1.045 4.966 4.966 0 0 0-1.894-1.894 1 1 0 0 0-1.045 1.576l-3.237-3.237a.998.998 0 0 0-1.414 0l-5.656 5.656a.998.998 0 0 0 0 1.414l3.237 3.237z"/><path d="M14.5 9.5 9.5 14.5"/></svg>,
      Castle:({size=20,className=""})=><svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M4 4v16"/><path d="M20 4v16"/><path d="M12 4v16"/><path d="M2 8h20"/><path d="M8 8v4"/><path d="M16 8v4"/><path d="M8 16h8"/><path d="M8 12h8"/><path d="M8 4l2-2 2 2"/><path d="M14 4l2-2 2 2"/></svg>,
    };

    class ErrorBoundary extends React.Component{ constructor(props){super(props);this.state={hasError:false,error:null}} static getDerivedStateFromError(error){return{hasError:true,error}} componentDidCatch(error,errorInfo){console.error("React Error:",error,errorInfo)} render(){ if(this.state.hasError){ return(<div className="p-8 text-center text-white bg-red-900 h-screen flex flex-col items-center justify-center"><h1 className="text-2xl font-bold mb-4">ì•± ì˜¤ë¥˜ ë°œìƒ</h1><pre className="bg-black p-4 rounded text-left text-xs overflow-auto max-w-full">{this.state.error&&this.state.error.toString()}</pre><button onClick={()=>{localStorage.clear();window.location.reload();}} className="mt-6 bg-white text-black px-4 py-2 rounded font-bold">ì´ˆê¸°í™” ë° ìƒˆë¡œê³ ì¹¨</button></div>); } return this.props.children; } }

    const RankingBar=({db,appId,player})=>{
      const [levelRanking,setLevelRanking]=React.useState([]),[atkRanking,setAtkRanking]=React.useState([]);
      const calcAtk=React.useCallback(u=>Number(u?.baseAtk||0)+Number(u?.equippedWeapon?.atk||0),[]); // âœ… í˜„ì¬ ì „íˆ¬ ê¸°ì¤€ ATK
      React.useEffect(()=>{ if(!db) return; const baseRef=db.collection("artifacts").doc(appId).collection("accounts");
        // âœ… í•œ ë²ˆì— ë°›ì•„ì„œ(ì˜ˆ: ìµœëŒ€ 200ëª…) í´ë¼ì—ì„œ ì •ë ¬ â†’ í•„ë“œ ì—†ì–´ë„ OK
        const unsub=baseRef.limit(200).onSnapshot(snap=>{ const users=snap.docs.map(d=>({id:d.id,...d.data()}));
          const lvl=[...users].sort((a,b)=>Number(b.level||0)-Number(a.level||0)).slice(0,5);
          const atk=[...users].sort((a,b)=>calcAtk(b)-calcAtk(a)).slice(0,5);
          setLevelRanking(lvl); setAtkRanking(atk);
        });
        return ()=>unsub();
      },[db,appId,calcAtk]);

      const NameChip=({u,i,value,colorClass})=>(
        <span key={u.id} className={`text-xs px-2 py-1 rounded-full bg-slate-800/70 border border-slate-700 whitespace-nowrap ${u.name===player.name?"text-yellow-300 font-bold border-yellow-500/40":"text-gray-200"}`}>
          {i+1}.{u.name}({value})
        </span>
      );

      return (
        <div className="bg-slate-900/60 border-t border-slate-700 px-3 py-2">
          {/* âœ… 1ì¤„: ë ˆë²¨ ë­í‚¹ */}
          <div className="flex items-center gap-2 flex-wrap"><span className="text-blue-300 font-bold text-sm w-10">Lv</span>{levelRanking.map((u,i)=>(<NameChip u={u} i={i} value={u.level??0}/>))}</div>
          {/* âœ… 2ì¤„: ATK ë­í‚¹ (í˜„ì¬ ì „íˆ¬ ê¸°ì¤€) */}
          <div className="flex items-center gap-2 flex-wrap mt-2"><span className="text-red-300 font-bold text-sm w-10">ATK</span>{atkRanking.map((u,i)=>(<NameChip u={u} i={i} value={calcAtk(u)}/>))}</div>
        </div>
      );
    };
    // âœ… ëª¬ìŠ¤í„° ì´ë¯¸ì§€ í…Œì´ë¸”(ì—†ìœ¼ë©´ null â†’ emojië¡œ ëŒ€ì²´)
const FIELD_IMGS = [
  "https://i.postimg.cc/Dy5jqxfh/ganji-gamja.png",
  "https://i.postimg.cc/BQNYxmZ4/gamdong-gamja.png",
  "https://i.postimg.cc/9F18GLXh/melong-gamja.png",
  "https://i.postimg.cc/15MCpvR5/uneun-gamja.png",
  "https://i.postimg.cc/ZKj7rwYb/usneun-gamja.png",
  "https://i.postimg.cc/PrK3mSfh/kojubu-gamja.png"
];

const LEGEND_IMGS = [
  null, // ğŸ‰ ë“œë˜ê³¤ ë‚˜ì´íŠ¸
  null, // ğŸ˜ˆ ê³ ëŒ€ ì•…ë§ˆ
  null, // ğŸ‘¼ íƒ€ë½í•œ ì²œì‚¬
  null  // ğŸ‘ï¸ ì‹¬ì—°ì˜ ê°ì‹œì
];

const BOSS_IMG = null; // âœ… ë³´ìŠ¤ë„ ì´ë¯¸ì§€ ë„£ê³  ì‹¶ìœ¼ë©´ URLë¡œ êµì²´

const TOWER_IMGS = [
  null, // ğŸ—¿ íƒ‘ì˜ ìˆ˜í˜¸ì
  null, // âš”ï¸ ê´‘ê¸°ì˜ ê¸°ì‚¬
  null, // ğŸ‘» ì‹¬ì—°ì˜ ë§ë ¹
  null  // ğŸ‘ï¸ ì €ì£¼ë°›ì€ ê°ì‹œì
];

// ===== Town Lobby (RPG Village) v1 =====
const TOWN = {
  W: 1400,
  H: 900,
  SPEED: 1,
  STALE_MS: 20000,
};

// NPC/í¬íƒˆ(ìƒí˜¸ì‘ìš© ì˜¤ë¸Œì íŠ¸)
const TOWN_OBJECTS = [
  { id: "forge", type: "npc", label: "ëŒ€ì¥ê°„", emoji: "ğŸ”¨", x: 620, y: 620, w: 110, h: 110 },
  { id: "training", type: "portal", label: "ìˆ˜ë ¨ì˜ ìˆ²", emoji: "ğŸŒ²", x: 420, y: 220, w: 110, h: 110 },
  { id: "legend", type: "portal", label: "ì „ì„¤ì˜ ë˜ì „", emoji: "ğŸ°", x: 540, y: 220, w: 110, h: 110 },
  { id: "boss", type: "portal", label: "ë³´ìŠ¤ ë ˆì´ë“œ", emoji: "ğŸ’€", x: 680, y: 220, w: 110, h: 110 },
  { id: "tower", type: "portal", label: "ì‹œë ¨ì˜ íƒ‘", emoji: "ğŸ—¼", x: 800, y: 220, w: 110, h: 110 },
  { id: "quest", type: "npc", label: "í€˜ìŠ¤íŠ¸", emoji: "ğŸ“œ", x: 740, y: 620, w: 110, h: 110 },
];

// ê°„ë‹¨ ì¶©ëŒìš© â€œê±´ë¬¼â€ (ì§€ë‚˜ë‹¤ë‹ˆë©´ ì•ˆ ë˜ëŠ” êµ¬ì—­)
const TOWN_BLOCKS = [];

// AABB ì¶©ëŒ
const intersects = (a, b) =>
  a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;

// ê±°ë¦¬(ìƒí˜¸ì‘ìš©)
const dist2 = (ax, ay, bx, by) => {
  const dx = ax - bx, dy = ay - by;
  return dx*dx + dy*dy;
};
// âœ… TownSceneì„ App ë°–ìœ¼ë¡œ ë¹¼ê¸° (ì»¤ì„œ ì•ˆ ì‚¬ë¼ì§)
function TownScene({
  player,
  townPos,
  others,
  chatOpen,
  setChatOpen,
  chatInput,
  setChatInput,
  chatMessages,
  sendChat,
  chatInputRef,
}) {
  // ì¹´ë©”ë¼(ë‚´ ìºë¦­í„° ì¤‘ì‹¬)
  const vw = 900, vh = 520;
  const camX = Math.max(0, Math.min(TOWN.W - vw, townPos.x - vw / 2));
  const camY = Math.max(0, Math.min(TOWN.H - vh, townPos.y - vh / 2));

  const meStyle = {
    left: townPos.x - 16 - camX,
    top: townPos.y - 16 - camY,
  };

  return (
    <div className="p-4 max-w-5xl mx-auto w-full">
      <div className="flex items-center justify-between mb-3">
        <div>
          <div className="text-2xl font-bold text-blue-200">ğŸ˜ï¸ ê°ì ë§ˆì„</div>
          <div className="text-xs text-gray-400">ì´ë™: WASD/ë°©í–¥í‚¤ Â· ìƒí˜¸ì‘ìš©: E</div>
        </div>
        <div className="text-xs text-gray-300 bg-slate-800/70 border border-slate-700 rounded px-3 py-2">
          ì ‘ì†ì: <b className="text-yellow-300">{1 + (others?.length || 0)}</b>
        </div>
      </div>

      <div
        className="relative rounded-xl border border-slate-700 overflow-hidden bg-slate-900 shadow-2xl"
        style={{ width: "100%", maxWidth: vw, aspectRatio: "900 / 520" }}
      >
        {/* ì›”ë“œ ë°°ê²½ */}
        <div
          className="absolute inset-0"
          style={{
            width: vw,
            height: vh,
            background:
              "radial-gradient(circle at 40% 40%, rgba(34,197,94,0.20), transparent 45%)," +
              "radial-gradient(circle at 70% 70%, rgba(59,130,246,0.15), transparent 45%)," +
              "linear-gradient(180deg, rgba(15,23,42,0.95), rgba(2,6,23,0.95))",
          }}
        />

        {/* ë§µ ë ˆì´ì–´ */}
        <div className="absolute inset-0" style={{ width: vw, height: vh }}>
          {/* ë°”ë‹¥(ê¸¸) */}
          <div
            className="absolute rounded-full opacity-40"
            style={{
              left: 80 - camX,
              top: 420 - camY,
              width: 1200,
              height: 220,
              background: "rgba(148,163,184,0.18)",
            }}
          />
          <div
            className="absolute rounded-full opacity-35"
            style={{
              left: 420 - camX,
              top: 120 - camY,
              width: 720,
              height: 200,
              background: "rgba(148,163,184,0.16)",
            }}
          />

          {/* ì¶©ëŒ ë¸”ë¡ */}
          {TOWN_BLOCKS.map((b, i) => (
            <div
              key={i}
              className="absolute rounded-lg border border-slate-700/60 bg-slate-800/30"
              style={{ left: b.x - camX, top: b.y - camY, width: b.w, height: b.h }}
              title="ê±´ë¬¼"
            />
          ))}

          {/* ì˜¤ë¸Œì íŠ¸(NPC/í¬íƒˆ) */}
          {TOWN_OBJECTS.map((o) => (
            <div
              key={o.id}
              className="absolute flex flex-col items-center justify-center rounded-xl border border-slate-600 bg-black/20 hover:bg-black/30 transition"
              style={{ left: o.x - camX, top: o.y - camY, width: o.w, height: o.h }}
            >
              <div className="text-3xl">{o.emoji}</div>
              <div className="text-[11px] text-gray-200 mt-1 font-bold">{o.label}</div>
              <div className="text-[10px] text-gray-400">E</div>
            </div>
          ))}

          {/* ë‹¤ë¥¸ í”Œë ˆì´ì–´ */}
          {(others || []).map((u) => (
            <div
              key={u.id}
              className="absolute"
              style={{ left: (u.x || 0) - 16 - camX, top: (u.y || 0) - 16 - camY }}
            >
              <div className="text-[10px] text-gray-200 text-center mb-1 drop-shadow">
                {u.name || "??"}
              </div>
              <div className="w-8 h-8 rounded-full bg-purple-500/70 border border-purple-200/30 flex items-center justify-center shadow">
                <span className="text-white text-sm">ğŸ™‚</span>
              </div>
            </div>
          ))}

          {/* ë‚´ í”Œë ˆì´ì–´ */}
          <div className="absolute" style={meStyle}>
            <div className="text-[10px] text-yellow-200 text-center mb-1 drop-shadow font-bold">
              {player?.name || "??"}
            </div>
            <div className="w-8 h-8 rounded-full bg-blue-500 border border-blue-200/40 flex items-center justify-center shadow-xl">
              <span className="text-white text-sm">ğŸ§‘</span>
            </div>
          </div>
        </div>

        {/* âœ… ì±„íŒ… UI: ë‹«íˆë©´ ë¯¸ë‹ˆ(ìµœê·¼ 3ê°œ), ì—´ë¦¬ë©´ ì „ì²´ */}
<div className="absolute left-3 bottom-3 w-[200px] max-w-[92vw]">
  {!chatOpen ? (
    // ====== ë¯¸ë‹ˆ ë·°(ë‹«í˜) ======
    <button
      onClick={() => setChatOpen(true)}
      className="w-full text-left bg-slate-900/65 border border-slate-700 rounded-lg px-3 py-2 shadow-xl hover:bg-slate-900/80 transition"
      title="Shiftë¡œ ì±„íŒ… ì—´ê¸°"
    >
      <div className="flex items-center justify-between">
        <div className="text-[11px] text-gray-300 font-bold">
          ğŸ’¬ ì±„íŒ… <span className="text-gray-500">(Shiftë¡œ ì…ë ¥)</span>
        </div>
        <div className="text-[10px] text-gray-400">ì—´ê¸°</div>
      </div>

      <div className="mt-2 space-y-1">
        {(chatMessages || []).length === 0 ? (
          <div className="text-[11px] text-gray-500">ìµœê·¼ ë©”ì‹œì§€ê°€ ì—†ì–´ìš”.</div>
        ) : (
          (chatMessages || []).slice(-3).map((m, i) => (
            <div key={i} className="text-[11px] leading-snug truncate">
              <span className="text-yellow-200 font-bold">{m.name || "??"}</span>
              <span className="text-gray-500">: </span>
              <span className="text-gray-100">{m.text}</span>
            </div>
          ))
        )}
      </div>
    </button>
  ) : (
    // ====== ì „ì²´ ë·°(ì—´ë¦¼) ======
    <div className="bg-slate-900/80 border border-slate-700 rounded-lg p-2 text-xs text-gray-200 shadow-xl">
      <div className="flex items-center justify-between mb-1">
        <div className="text-[11px] text-gray-300">
          ğŸ’¬ ì±„íŒ… <span className="text-gray-500">(Enter: ì „ì†¡ / Esc: ë‹«ê¸°)</span>
        </div>
        <button
          onClick={() => { setChatOpen(false); setChatInput(""); }}
          className="text-[10px] px-2 py-1 rounded bg-slate-800 hover:bg-slate-700 text-gray-200 border border-slate-700"
        >
          ë‹«ê¸°
        </button>
      </div>

      {/* ë©”ì‹œì§€ ë¦¬ìŠ¤íŠ¸ */}
      <div className="h-[130px] overflow-y-auto bg-black/30 rounded p-2 border border-slate-800">
        {(chatMessages || []).length === 0 ? (
          <div className="text-gray-500">ì•„ì§ ì±„íŒ…ì´ ì—†ì–´ìš”.</div>
        ) : (
          (chatMessages || []).slice(-30).map((m, i) => (
            <div key={i} className="leading-snug">
              <span className="text-yellow-200 font-bold">{m.name || "??"}</span>
              <span className="text-gray-500">: </span>
              <span className="text-gray-100">{m.text}</span>
            </div>
          ))
        )}
      </div>

      {/* ì…ë ¥ì°½ */}
      <div className="mt-2 flex gap-2">
        <input
          ref={chatInputRef}
          value={chatInput}
          onChange={(e) => setChatInput(e.target.value)}

          // âœ… window keydownìœ¼ë¡œ íŠ€ëŠ”ê±° ë°©ì§€(ìœ ì§€)
          onKeyDown={(e) => e.stopPropagation()}
          onKeyUp={(e) => e.stopPropagation()}

          placeholder="ì±„íŒ… ì…ë ¥..."
          className="flex-1 px-2 py-2 rounded bg-slate-800 border border-slate-700 text-gray-100 outline-none"
        />
        <button
          onClick={sendChat}
          className="px-3 py-2 rounded bg-blue-600 hover:bg-blue-500 text-white font-bold"
        >
          ì „ì†¡
        </button>
      </div>
    </div>
  )}
</div>


      </div>
    </div>
  );
}

    function App(){
      const [loading,setLoading]=useState(true),[errorMsg,setErrorMsg]=useState(null),[view,setView]=useState("login"),[loginName,setLoginName]=useState(""),[loginPw,setLoginPw]=useState("");
      const [forgeSelected,setForgeSelected]=useState([]); // ì„ íƒí•œ ë¬´ê¸° id 10ê°œ
      const [forgeTargetRarity,setForgeTargetRarity]=useState(null),[forgeMiniGame,setForgeMiniGame]=useState(null),[forgePhase,setForgePhase]=useState("ready"),[forgeResult,setForgeResult]=useState(null);
      const forgeTimerRef=useRef(null); const [forgeErrorIndex,setForgeErrorIndex]=useState(null);
      const [invTab,setInvTab]=useState("weapon"),[invSort,setInvSort]=useState("rarity");
      const [lobbyPage, setLobbyPage] = useState("main"); // "main" | "training"
const [townPos, setTownPos] = useState({ x: 820, y: 560, dir: "down" });
const [others, setOthers] = useState([]); // {id,name,x,y,dir,updatedAt}
const [sideTab, setSideTab] = useState("equip"); // "equip" | "enhance"
const [trainingOpen, setTrainingOpen] = useState(false);
const TRAINING_SUBJECTS = ["êµ­ì–´","ìˆ˜í•™","ì‚¬íšŒ","ê³¼í•™","ìƒì‹"];
const townLastSendRef = useRef(0);
// âœ… Town Chat
const [chatOpen, setChatOpen] = useState(false);
const [chatInput, setChatInput] = useState("");
const [chatMessages, setChatMessages] = useState([]); // [{name,text,ts}]
const chatInputRef = useRef(null);
const chatOpenRef = useRef(false);
useEffect(()=>{ chatOpenRef.current = chatOpen; }, [chatOpen]);
useEffect(() => {
  if (view === "lobby" && chatOpen) {
    setTimeout(() => chatInputRef.current?.focus(), 0);
  }
}, [chatOpen, view]);


const attemptInteract = () => {
  const tp = townPosRef.current || townPos;
  const meBox = { x: tp.x - 16, y: tp.y - 16, w: 32, h: 32 };

  const PAD = 15;
  const near = (obj) =>
    intersects(meBox, { x: obj.x - PAD, y: obj.y - PAD, w: obj.w + PAD * 2, h: obj.h + PAD * 2 });

  // ğŸ‘‡ğŸ‘‡ğŸ‘‡ ì—¬ê¸°! (ì›ë˜ find(near) ìˆë˜ ìë¦¬ë¥¼ êµì²´)
  const myCx = tp.x;
  const myCy = tp.y;

  const candidates = TOWN_OBJECTS.filter(near);
  const obj = candidates.length
    ? candidates
        .map(o => {
          const ox = o.x + o.w / 2;
          const oy = o.y + o.h / 2;
          return { o, d: dist2(myCx, myCy, ox, oy) };
        })
        .sort((a, b) => a.d - b.d)[0].o
    : null;
  // ğŸ‘†ğŸ‘†ğŸ‘† ì—¬ê¸°ê¹Œì§€

  if (!obj) {
    showMessage("ê·¼ì²˜ì— ìƒí˜¸ì‘ìš© ëŒ€ìƒì´ ì—†ìŠµë‹ˆë‹¤. (E í‚¤)", "info");
    return;
  }

  if (obj.id === "forge") { setView("forge"); return; }

  if (obj.id === "quest") {
    const e = ensureDaily(player);
    if (e.changed) savePlayerData(e.player);
    setQuestOpen(true);
    return;
  }

  if (obj.id === "training") {
    setTrainingOpen(true);
    return;
  }

  if (obj.id === "legend") { tryEnterLegendDungeon(); return; }
  if (obj.id === "boss") { tryEnterBoss(); return; }
  if (obj.id === "tower") { enterTower(); return; }
};




// âœ… Trial Tower (ì‹œë ¨ì˜ íƒ‘)
const TOWER_MAX_FLOOR = 100;
const TOWER_REST_FLOORS = [1,20,40,60,80];              
const TOWER_SAVE_FLOORS = [1,20,40,60,80]; 

const towerCheckpointFor = (floor) => {
  if(floor<=20) return 1;
  if(floor<=40) return 20;
  if(floor<=60) return 40;
  if(floor<=80) return 60;
  return 80; // 81~100
};

const towerSubjectFor = (floor) => {
  if(floor<=20) return "êµ­ì–´(ì‹œë ¨)";
  if(floor<=40) return "ìˆ˜í•™(ì‹œë ¨)";
  if(floor<=60) return "ì‚¬íšŒ(ì‹œë ¨)";
  if(floor<=80) return "ê³¼í•™(ì‹œë ¨)";
  const all = ["êµ­ì–´(ì‹œë ¨)","ìˆ˜í•™(ì‹œë ¨)","ì‚¬íšŒ(ì‹œë ¨)","ê³¼í•™(ì‹œë ¨)","ìƒì‹(ì‹œë ¨)"];
  return all[Math.floor(Math.random()*all.length)];
};

const [towerFloor,setTowerFloor] = useState(1);
const [towerCheckpoint,setTowerCheckpoint] = useState(1);

useEffect(() => {if (view === "lobby") setLobbyPage("main");}, [view]);

      useEffect(()=>{ if(!forgeMiniGame||forgePhase!=="ready") return; const timer=setTimeout(()=>{ setForgeMiniGame(prev=>{ if(!prev) return prev; return {...prev,phase:"play"}; // ğŸ¯ ì‹¤ì œ ì‹œì‘
      }); },5000); // 5ì´ˆ ì½ê¸° ì‹œê°„
      return()=>clearTimeout(timer); },[forgeMiniGame]);

      // ğŸ”¥ ëŒ€ì¥ê°„ ë¯¸ë‹ˆê²Œì„ í‚¤ ì…ë ¥ ì²˜ë¦¬
      useEffect(()=>{ if(!forgeMiniGame||forgePhase!=="play") return; const handleKeyDown=(e)=>{ const key=e.key.toLowerCase(); if(!/^[a-z]$/.test(key)) return;
        setForgeMiniGame(prev=>{ if(!prev) return prev; const nextInput=prev.input+key;
          // âŒ í‹€ë¦° ì…ë ¥
          if(!prev.keys.startsWith(nextInput)){ failForge(); return null; }
          // âœ… ì„±ê³µ
          if(nextInput===prev.keys){ successForge(); return null; }
          return {...prev,input:nextInput};
        });
      };
      window.addEventListener("keydown",handleKeyDown); return()=>window.removeEventListener("keydown",handleKeyDown); },[forgeMiniGame,forgePhase]);

      // â±ï¸ ëŒ€ì¥ê°„ ë¯¸ë‹ˆê²Œì„ ì‹œê°„ ê°ì†Œ ì²˜ë¦¬
      useEffect(()=>{ if(!forgeMiniGame||forgePhase!=="play") return;
        forgeTimerRef.current=setInterval(()=>{ setForgeMiniGame(prev=>{ if(!prev) return prev; const nextTime=prev.timeLeft-50;
          // â›” ì‹œê°„ ì´ˆê³¼
          if(nextTime<=0){ clearInterval(forgeTimerRef.current); failForge(); return null; }
          return {...prev,timeLeft:nextTime};
        }); },50);
        return()=>clearInterval(forgeTimerRef.current);
      },[forgeMiniGame,forgePhase]);

const defaultPlayer={name:"ëª¨í—˜ê°€",level:1,exp:0,maxExp:100,hp:100,baseMaxHp:100,maxHp:100,gold:0,baseAtk:10,equippedWeapon:null,equippedArmor:null,inventory:[],solved:[],fragments:{"êµ­ì–´":0,"ìˆ˜í•™":0,"ì‚¬íšŒ":0,"ê³¼í•™":0,"ìƒì‹":0},stones:0,dailyQuest:null,dailyQuestProgress:null,dailyQuestClaimed:null,towerFloor: 1,towerCheckpoint: 1,};
      const [player,setPlayer]=useState(defaultPlayer),[monster,setMonster]=useState(null),[currentSubject,setCurrentSubject]=useState("ìˆ˜í•™"),[currentQuestion,setCurrentQuestion]=useState(null);
      const [battleLog,setBattleLog]=useState([]),[bossStreak,setBossStreak]=useState(0),[isRespawning,setIsRespawning]=useState(false),[questions,setQuestions]=useState([]);
      const [message,setMessage]=useState(null),[accountId,setAccountId]=useState(null),[wrongAnswerModal,setWrongAnswerModal]=useState(null);
// âœ… ì±„íŒ… ë¬¸ì„œ(ref) - ë‹¨ì¼ ë¬¸ì„œì— messages 100ê°œ ìœ ì§€
const chatDocRef = React.useMemo(() => {
  if (!db) return null;
  return db.collection("artifacts").doc(appId).collection("townChat").doc("global");
}, [db, appId]);

// âœ… ì±„íŒ… êµ¬ë…
useEffect(() => {
  if (view !== "lobby") return;
  if (!chatDocRef) return;

  const unsub = chatDocRef.onSnapshot((doc) => {
    const data = doc.data() || {};
    const msgs = Array.isArray(data.messages) ? data.messages : [];
    setChatMessages(msgs);
  });

  return () => unsub();
}, [view, chatDocRef]);
// âœ… ì¥ë¹„ ë³´í˜¸(2ì´ˆ ë¡±í”„ë ˆìŠ¤)
const protectPressRef = useRef(null);
const protectDownAtRef = useRef(0);
const protectTriggeredRef = useRef(false);
const protectIsDownRef = useRef(false);

const clearProtectPress = () => {
  if (protectPressRef.current) {
    clearTimeout(protectPressRef.current);
    protectPressRef.current = null;
  }
};

// âœ… ì‹œì‘(2ì´ˆ íƒ€ì´ë¨¸)
const startProtectPress = (item, e) => {
  if (!item) return;
  if (item.type !== "weapon" && item.type !== "armor") return;

  // âœ… ë§ˆìš°ìŠ¤ëŠ” í´ë¦­(ì¢Œí´ë¦­)ì¼ ë•Œë§Œ
  if (e?.pointerType === "mouse" && e.buttons !== 1) return;

  clearProtectPress();
  protectIsDownRef.current = true;     // âœ… ëˆ„ë¥´ê¸° ì‹œì‘
  protectTriggeredRef.current = false;
  protectDownAtRef.current = Date.now();

  protectPressRef.current = setTimeout(() => {
    if (!protectIsDownRef.current) return; // âœ… ì´ë¯¸ ì† ë—ìœ¼ë©´ ë¬´ì‹œ
    protectTriggeredRef.current = true;
    toggleProtectItem(item.id);
    clearProtectPress();
  }, 2000);
};


// âœ… ì¢…ë£Œ(ì† ë—„ ë•Œ) - 2ì´ˆë¥¼ ë„˜ê²¼ëŠ”ë° íƒ€ì´ë¨¸ê°€ ì•ˆ í„°ì¡Œìœ¼ë©´ ì—¬ê¸°ì„œë¼ë„ í† ê¸€
const cancelProtectPress = (item) => {
  // âœ… ì§€ê¸ˆ ëˆ„ë¥´ëŠ” ì¤‘ì´ ì•„ë‹ˆë©´(hover/leaveë§Œ ë°œìƒ) ì•„ë¬´ê²ƒë„ í•˜ì§€ ì•ŠìŒ
  if (!protectIsDownRef.current) return;

  const held = Date.now() - (protectDownAtRef.current || 0);

  // íƒ€ì´ë¨¸ race ë³´ì •(ì§„ì§œ ì˜¤ë˜ ëˆŒë €ëŠ”ë° setTimeoutì´ ëª» ëˆ ê²½ìš°)
  if (!protectTriggeredRef.current && item?.id && held >= 1950) {
    toggleProtectItem(item.id);
  }

  protectIsDownRef.current = false;     // âœ… ëˆ„ë¥´ê¸° ì¢…ë£Œ
  protectDownAtRef.current = 0;         // âœ… ì‹œê°„ ë¦¬ì…‹ (í•µì‹¬!)
  protectTriggeredRef.current = false;  // âœ… ë¦¬ì…‹
  clearProtectPress();
};


  // âœ… ë¬´ê¸° ë³´í˜¸ í† ê¸€
const toggleProtectItem = (itemId) => {
  const newPlayer = {
    ...player,
    inventory: [...(player.inventory || [])],
  };

  const t = newPlayer.inventory.find(i => i.id === itemId);
  if (!t) return;

  // âœ… ë¬´ê¸°ë§Œ ë³´í˜¸ í† ê¸€
if (t.type !== "weapon" && t.type !== "armor") return;

  t.protected = !t.protected;
  showMessage(t.protected ? "ğŸ”’ ì¥ë¹„ ë³´í˜¸ ON (íŒë§¤/ì¡°í•© ë¶ˆê°€)" : "ğŸ”“ ì¥ë¹„ ë³´í˜¸ OFF", "info");

  // ì¥ì°©ì¤‘ì¸ ì°¸ì¡°ë„ ìµœì‹ ìœ¼ë¡œ
  if (newPlayer.equippedWeapon?.id === t.id) newPlayer.equippedWeapon = t;
  if (newPlayer.equippedArmor?.id === t.id) newPlayer.equippedArmor = t;


  savePlayerData(newPlayer);
};


// âœ… presence ref
const presenceRef = React.useMemo(() => {
  if (!db || !accountId) return null;
  return db.collection("artifacts").doc(appId).collection("lobbyPresence").doc(accountId);
}, [db, appId, accountId]);


// âœ… ì´ë™ ì…ë ¥ + ì¶©ëŒ ì²˜ë¦¬
// âœ… ìµœì‹  í•¨ìˆ˜/ì¢Œí‘œë¥¼ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆê°€ í•­ìƒ ë³´ê²Œ ë§Œë“¤ê¸° ìœ„í•œ ref
const attemptInteractRef = useRef(() => {});
const townPosRef = useRef(townPos);

// townPos ìµœì‹ í™”
useEffect(() => { townPosRef.current = townPos; }, [townPos]);

// attemptInteract ìµœì‹ í™” (ì•„ë˜ì—ì„œ attemptInteract í•¨ìˆ˜ ì •ì˜ í›„ì— ìë™ìœ¼ë¡œ ì—°ê²°ë¨)
useEffect(() => { attemptInteractRef.current = attemptInteract; });

// âœ… ì´ë™ ì…ë ¥ + ì¶©ëŒ ì²˜ë¦¬ (IME(í•œê¸€)ì—ì„œë„ WASD/E ë™ì‘í•˜ë„ë¡ e.code ê¸°ë°˜)
useEffect(() => {
  if (view !== "lobby") return;

  const keys = new Set();

  const normKey = (e) => {
    switch (e.code) {
      case "KeyW": return "w";
      case "KeyA": return "a";
      case "KeyS": return "s";
      case "KeyD": return "d";
      case "KeyE": return "e";
      default: return (e.key || "").toLowerCase();
    }
  };

  const openChat = () => {
    setChatOpen(true);
    // âœ… í˜¹ì‹œ ì´ì „ì— ëˆŒë¦° ì´ë™í‚¤ê°€ ë‚¨ì•„ìˆìœ¼ë©´ ë©ˆì¶”ê²Œ
    keys.clear();
    setTimeout(() => chatInputRef.current?.focus(), 0);
  };

  const onDown = (e) => {
    const k = normKey(e);
    const isChat = chatOpenRef.current; // âœ… ìµœì‹  ìƒíƒœ

    // âœ… Shift ëˆ„ë¥´ë©´ ì±„íŒ… ì—´ê¸°(í•œ ë²ˆ ëˆ„ë¥´ë©´ ìœ ì§€)
    if (!isChat && (e.code === "ShiftLeft" || e.code === "ShiftRight")) {
      e.preventDefault();
      openChat();
      return;
    }

    // âœ… ì±„íŒ… ì—´ë ¤ìˆìœ¼ë©´ ì´ë™/ìƒí˜¸ì‘ìš© ì™„ì „ ì°¨ë‹¨
    if (isChat) {
      // ì´ë™í‚¤ê°€ ë‚¨ì•„ìˆìœ¼ë©´ ë©ˆì¶”ê²Œ
      if (["arrowup","arrowdown","arrowleft","arrowright","w","a","s","d"].includes(k)) {
        keys.clear();
        return; // ê¸€ìëŠ” inputì´ ë°›ê²Œ ë‘ 
      }

      if (k === "escape") {
        e.preventDefault();
        setChatOpen(false);
        setChatInput("");
        keys.clear();
        return;
      }

      if (k === "enter") {
        e.preventDefault();
        sendChat();
        return;
      }

      return;
    }

    // ===== ì±„íŒ… ë‹«í˜€ìˆì„ ë•Œë§Œ ì´ë™/ìƒí˜¸ì‘ìš© =====
    if (["arrowup","arrowdown","arrowleft","arrowright","w","a","s","d"].includes(k)) {
      e.preventDefault();
      keys.add(k);
    }

    if (k === "e") {
      e.preventDefault();
      attemptInteractRef.current?.();
    }
  };

  const onUp = (e) => {
    // âœ… ì±„íŒ… ì—´ë ¤ìˆìœ¼ë©´ í‚¤ ìƒíƒœ ë§Œì§€ì§€ ì•ŠìŒ(ì´ë™ ì¤‘ì§€ ìœ ì§€)
    if (chatOpenRef.current) return;
    keys.delete(normKey(e));
  };

  window.addEventListener("keydown", onDown, { passive: false });
  window.addEventListener("keyup", onUp);

  let raf = 0;
  const tick = () => {
    // âœ… ì±„íŒ… ì¤‘ì—ëŠ” ì•„ì˜ˆ ì´ë™ ê³„ì‚° ìì²´ë¥¼ ì•ˆ í•¨
    if (chatOpenRef.current) {
      keys.clear();
      raf = requestAnimationFrame(tick);
      return;
    }

    let dx = 0, dy = 0, dir = townPosRef.current?.dir || "down";

    if (keys.has("arrowup") || keys.has("w")) { dy -= TOWN.SPEED; dir = "up"; }
    if (keys.has("arrowdown") || keys.has("s")) { dy += TOWN.SPEED; dir = "down"; }
    if (keys.has("arrowleft") || keys.has("a")) { dx -= TOWN.SPEED; dir = "left"; }
    if (keys.has("arrowright") || keys.has("d")) { dx += TOWN.SPEED; dir = "right"; }

    if (dx || dy) {
      setTownPos(prev => {
        const next = {
          ...prev,
          dir,
          x: Math.max(20, Math.min(TOWN.W - 20, prev.x + dx)),
          y: Math.max(20, Math.min(TOWN.H - 20, prev.y + dy)),
        };

        const meBox = { x: next.x - 16, y: next.y - 16, w: 32, h: 32 };
        for (const b of TOWN_BLOCKS) {
          if (intersects(meBox, b)) return prev;
        }
        return next;
      });
    }

    raf = requestAnimationFrame(tick);
  };

  raf = requestAnimationFrame(tick);

  return () => {
    cancelAnimationFrame(raf);
    window.removeEventListener("keydown", onDown);
    window.removeEventListener("keyup", onUp);
  };
}, [view]);


// âœ… ë‚´ ìœ„ì¹˜ ì—…ë¡œë“œ(throttle)
useEffect(() => {
  if (view !== "lobby") return;
  if (!presenceRef) return;

  const now = Date.now();
  if (now - townLastSendRef.current < 150) return;
  townLastSendRef.current = now;

  presenceRef.set({
    name: player.name,
    x: townPos.x,
    y: townPos.y,
    dir: townPos.dir,
    updatedAt: now,
  }, { merge: true }).catch(()=>{});
}, [townPos, view, presenceRef, player.name]);

// âœ… ë‹¤ë¥¸ ìœ ì € êµ¬ë…
useEffect(() => {
  if (view !== "lobby") return;
  if (!db) { setOthers([]); return; }

  const col = db.collection("artifacts").doc(appId).collection("lobbyPresence");
  const unsub = col.onSnapshot((snap) => {
    const now = Date.now();
    const list = snap.docs
      .map(d => ({ id: d.id, ...d.data() }))
      .filter(u => u.id !== accountId)
      .filter(u => (now - (u.updatedAt||0)) <= TOWN.STALE_MS);
    setOthers(list);
  });

  return () => unsub();
}, [db, appId, accountId, view]);

      useEffect(()=>{ let isMounted=true; const savedName=localStorage.getItem("last_login_name"); if(savedName) setLoginName(savedName);
        const safetyTimer=setTimeout(()=>{ if(isMounted){ console.warn("Loading timeout"); setErrorMsg("ì„œë²„ ì‘ë‹µ ì‹œê°„ì´ ì´ˆê³¼ë˜ì—ˆìŠµë‹ˆë‹¤. (10ì´ˆ)"); } },10000);
        if(!GOOGLE_SCRIPT_URL||GOOGLE_SCRIPT_URL.includes("ì—¬ê¸°ì—")){ clearTimeout(safetyTimer); if(isMounted){ setErrorMsg("URL ì„¤ì • ì˜¤ë¥˜: index.html íŒŒì¼ì˜ GOOGLE_SCRIPT_URLì„ í™•ì¸í•´ì£¼ì„¸ìš”."); setQuestions(MOCK_QUESTIONS); setLoading(false); } return; }
        fetch(GOOGLE_SCRIPT_URL).then(res=>{ if(!res.ok) throw new Error(`HTTP Error: ${res.status}`); return res.json(); }).then(data=>{ if(!isMounted) return; clearTimeout(safetyTimer);
          if(Array.isArray(data)&&data.length>0){ const formatted=data.map((item,index)=>({id:index,subject:item.subject,question:item.question,options:item.options,answer:parseInt(item.answer)-1})); setQuestions(formatted); setErrorMsg(null); }
          else throw new Error("ë°ì´í„°ê°€ ë¹„ì–´ìˆê±°ë‚˜ í˜•ì‹ì´ ì˜ëª»ë˜ì—ˆìŠµë‹ˆë‹¤.");
          setLoading(false);
        }).catch(err=>{ if(!isMounted) return; clearTimeout(safetyTimer); console.error("Fetch Error:",err); setErrorMsg(`ë°ì´í„° ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨: ${err.message}`); setQuestions(MOCK_QUESTIONS); setLoading(false); });
        if(auth) auth.signInAnonymously().catch(console.warn);
        return()=>{ isMounted=false; clearTimeout(safetyTimer); };
      },[]);

      useEffect(()=>{ if(!loading){ const loader=document.getElementById("loading-screen"); if(loader) loader.style.display="none"; } },[loading]);

      const showMessage=(text,type)=>{ setMessage({text,type}); setTimeout(()=>setMessage(null),3000); };
// =====================
const sendChat = async () => {
  const text = (chatInput || "").trim();
  if (!text) return;

  const msg = {
    name: (player.name || "??").slice(0, 20),
    text: text.slice(0, 200),
    ts: Date.now(),
  };

  // âœ… Firebase ì—†ìœ¼ë©´ ë¡œì»¬ë¡œë§Œ(í…ŒìŠ¤íŠ¸/ì˜¤í”„ë¼ì¸)
  if (!chatDocRef || !db) {
    setChatMessages(prev => {
      const next = [...prev, msg].slice(-100);
      localStorage.setItem("town_chat_local", JSON.stringify(next));
      return next;
    });
    setChatInput("");
    return;
  }

  try {
    await db.runTransaction(async (tx) => {
      const snap = await tx.get(chatDocRef);
      const data = snap.exists ? (snap.data() || {}) : {};
      const prev = Array.isArray(data.messages) ? data.messages : [];
      const next = [...prev, msg].slice(-100); // âœ… 100ê°œ ìœ ì§€
      tx.set(chatDocRef, {
        messages: next,
        updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
      }, { merge: true });
    });

    setChatInput("");
  } catch (e) {
    console.error(e);
    showMessage("ì±„íŒ… ì „ì†¡ ì‹¤íŒ¨(ë„¤íŠ¸ì›Œí¬/ê¶Œí•œ í™•ì¸)", "error");
  }
};
// âœ… StarCatch(10ê°• ì´ìƒ ê°•í™”ìš©)
const [starCatchOpen, setStarCatchOpen] = useState(false);
const [starCatchItem, setStarCatchItem] = useState(null);
const [starCatchT, setStarCatchT] = useState(0);
const [starCatchResult, setStarCatchResult] = useState(null);
const starCatchRafRef = useRef(null);
const starCatchLastRef = useRef(0);

const STAR_CATCH_BONUS = 0.2;
const STAR_WINDOW = { start: 0.45, end: 0.54 };
const STAR_SPEED = 1.5;

function stopStarCatchAnim(){
  if (starCatchRafRef.current) cancelAnimationFrame(starCatchRafRef.current);
  starCatchRafRef.current = null;
}

function startStarCatch(item){
  setStarCatchItem(item);
  setStarCatchResult(null);
  setStarCatchT(0);
  setStarCatchOpen(true);

  starCatchLastRef.current = performance.now();
  stopStarCatchAnim();

  let dir = 1;
  function tick(now){
    const dt = Math.min(0.05, (now - starCatchLastRef.current) / 1000);
    starCatchLastRef.current = now;

    setStarCatchT(prev => {
      let next = prev + dir * STAR_SPEED * dt;
      if (next >= 1) { next = 1; dir = -1; }
      if (next <= 0) { next = 0; dir = 1; }
      return next;
    });

    starCatchRafRef.current = requestAnimationFrame(tick);
  }

  starCatchRafRef.current = requestAnimationFrame(tick);
}

function resolveStarCatch(caught){
  if (!starCatchItem) return;
  stopStarCatchAnim();

  setStarCatchResult(caught ? "success" : "fail");

  setTimeout(() => {
    const bonus = caught ? STAR_CATCH_BONUS : 0;
    enhanceItem(starCatchItem, bonus);
    setStarCatchOpen(false);
    setStarCatchItem(null);
    setStarCatchResult(null);
  }, 1500);
};
function closeStarCatch(){
  stopStarCatchAnim();
  setStarCatchOpen(false);
  setStarCatchItem(null);
  setStarCatchResult(null);
}

// âœ… ìŠ¤íƒ€ìºì¹˜ ëª¨ë‹¬ (ë‹«ê¸° = ê°•í™” ì·¨ì†Œ)
const StarCatchModal = () => {
  if (!starCatchOpen || !starCatchItem) return null;

  const baseRate = 0.1; // 10ê°• ì´ìƒ ê¸°ë³¸ 10%
  const boosted = Math.min(0.95, baseRate + STAR_CATCH_BONUS);

  const closeStarCatch = (e) => {
    if (e) { e.preventDefault(); e.stopPropagation(); }
    stopStarCatchAnim();
    setStarCatchOpen(false);
    setStarCatchItem(null);
    setStarCatchResult(null);
  };

  // âœ… Escë¡œ ë‹«ê¸°(=ê°•í™” ì·¨ì†Œ)
  React.useEffect(() => {
    const onKeyDown = (e) => {
      if (e.key === "Escape") closeStarCatch(e);
    };
    window.addEventListener("keydown", onKeyDown, { passive: false });
    return () => window.removeEventListener("keydown", onKeyDown);
  }, [starCatchOpen, starCatchItem]);

  return (
    <div
      className="fixed inset-0 bg-black/80 flex items-center justify-center z-[1005]"
      onPointerDown={(e) => {
        // âœ… ë°”ê¹¥(ë°°ê²½) ëˆŒëŸ¬ì„œ ë‹«íˆëŠ” ê±° ë§‰ê³  ì‹¶ìœ¼ë©´ ì•„ë˜ ë‘ ì¤„ë§Œ ìœ ì§€
        // (ì›í•˜ë©´ "ë°°ê²½ ëˆŒëŸ¬ ë‹«ê¸°"ë„ êµ¬í˜„ ê°€ëŠ¥)
        e.stopPropagation();
      }}
    >
      <div
        className="bg-slate-800 border border-yellow-500 rounded-xl p-6 w-[92vw] max-w-sm shadow-2xl"
        onPointerDown={(e) => e.stopPropagation()} // âœ… ë‚´ë¶€ í´ë¦­ì´ ë°°ê²½ìœ¼ë¡œ ìƒˆì§€ ì•Šê²Œ
      >
        <div className="flex items-center justify-between mb-3">
          <h2 className="text-lg font-bold text-yellow-300">â­ ìŠ¤íƒ€ìºì¹˜</h2>

          {/* âœ… ë‹«ê¸° ë²„íŠ¼: onPointerDown + onClick(ë°±ì—…) */}
          <button
            type="button"
            onPointerDown={closeStarCatch}
            onClick={closeStarCatch}
            className="text-xs px-2 py-1 rounded bg-slate-700 hover:bg-slate-600 text-gray-100 pointer-events-auto touch-manipulation select-none"
            title="ì·¨ì†Œ"
          >
            ë‹«ê¸°
          </button>
        </div>

        <div className="text-xs text-gray-300 mb-3">
          ê°€ìš´ë° <b className="text-yellow-200">ë…¸ë€ êµ¬ê°„</b>ì— ë§ì¶° í´ë¦­í•˜ë©´ í™•ë¥ ì´ ì˜¬ë¼ê°‘ë‹ˆë‹¤.
        </div>

        <div className="text-[11px] text-gray-400 mb-3">
          ê¸°ë³¸ í™•ë¥ : <b className="text-gray-100">{(baseRate * 100).toFixed(0)}%</b>
          <span className="mx-2 text-gray-600">â†’</span>
          ì„±ê³µ ì‹œ: <b className="text-yellow-200">{(boosted * 100).toFixed(0)}%</b>
        </div>

        {/* íƒ€ì´ë° ë°” */}
        <div className="relative w-full h-4 bg-slate-700 rounded overflow-hidden border border-slate-600">
          <div
            className="absolute top-0 bottom-0 bg-yellow-400/60"
            style={{
              left: `${STAR_WINDOW.start * 100}%`,
              width: `${(STAR_WINDOW.end - STAR_WINDOW.start) * 100}%`,
            }}
          />
          <div
            className="absolute top-0 bottom-0 w-2 bg-white"
            style={{ left: `calc(${starCatchT * 100}% - 4px)` }}
          />
        </div>

        {/* ê²°ê³¼ */}
        {starCatchResult && (
          <div
            className={`mt-3 text-sm font-bold ${
              starCatchResult === "success" ? "text-green-400" : "text-gray-300"
            }`}
          >
            {starCatchResult === "success"
              ? "ì„±ê³µ! í™•ë¥  ìƒìŠ¹ ì ìš© ğŸ¯"
              : "ì‹¤íŒ¨! ì›ë˜ í™•ë¥ ë¡œ ì§„í–‰ ğŸ˜…"}
          </div>
        )}

        <div className="mt-4 flex gap-2">
          <button
            type="button"
            disabled={!!starCatchResult}
            onMouseDown={(e) => {
              e.preventDefault();
              e.stopPropagation();
              resolveStarCatch(starCatchT >= STAR_WINDOW.start && starCatchT <= STAR_WINDOW.end);
            }}
            className="flex-1 py-3 rounded font-bold border pointer-events-auto"
          >
            ì§€ê¸ˆ í´ë¦­!
          </button>

          <button
            type="button"
            disabled={!!starCatchResult}
            onMouseDown={(e) => {
              e.preventDefault();
              e.stopPropagation();
              resolveStarCatch(false);
            }}
            className="px-4 py-3 rounded font-bold border pointer-events-auto"
          >
            ìŠ¤í‚µ
          </button>
        </div>

        <div className="mt-3 text-[11px] text-gray-500">
          â€¢ ë‹«ê¸°/Esc: ì´ë²ˆ ê°•í™” ìì²´ë¥¼ ì·¨ì†Œí•©ë‹ˆë‹¤.<br />
          â€¢ ìŠ¤í‚µ: ë³´ë„ˆìŠ¤ ì—†ì´(ì„±ê³µ ì•„ë‹˜) ê°•í™” ì§„í–‰í•©ë‹ˆë‹¤.
        </div>
      </div>
    </div>
  );
};


// âœ… Daily Quest (ì¼ì¼ í€˜ìŠ¤íŠ¸)
// =====================
const todayKey=()=>{const d=new Date(),y=d.getFullYear(),m=String(d.getMonth()+1).padStart(2,"0"),dd=String(d.getDate()).padStart(2,"0");return `${y}-${m}-${dd}`;};
const rint=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;
const makeDailyQuest=()=>({date:todayKey(),missions:{
  kill:{target:rint(10,30),reward:{gold:rint(1000,10000),stone:rint(1,5)}},
  streak:{target:rint(10,20),reward:{gold:rint(1000,10000),stone:rint(1,5)}},
  boss:{target:rint(1,5),reward:{gold:rint(1000,10000),stone:rint(1,5)}}
}});
const initDailyProgress=()=>({kills:0,streakCur:0,streakBest:0,bossClears:0});
const initDailyClaimed=()=>({kill:false,streak:false,boss:false});

const [questOpen,setQuestOpen]=useState(false);
const ensureDaily=(p)=>{
  const tk=todayKey();
  let changed=false;
  const np={...p};
  if(!np.dailyQuest||np.dailyQuest.date!==tk){ np.dailyQuest=makeDailyQuest(); np.dailyQuestProgress=initDailyProgress(); np.dailyQuestClaimed=initDailyClaimed(); changed=true; }
  if(!np.dailyQuestProgress){ np.dailyQuestProgress=initDailyProgress(); changed=true; }
  if(!np.dailyQuestClaimed){ np.dailyQuestClaimed=initDailyClaimed(); changed=true; }
  if(typeof np.stones!=="number") { np.stones=0; changed=true; }
  return {player:np,changed};
};

const isQuestDone=(p,key)=>{
  const q=p.dailyQuest?.missions?.[key]; if(!q) return false;
  const pr=p.dailyQuestProgress||initDailyProgress();
  if(key==="kill") return (pr.kills||0)>=q.target;
  if(key==="streak") return (pr.streakBest||0)>=q.target;
  if(key==="boss") return (pr.bossClears||0)>=q.target;
  return false;
};

const claimQuest=(key)=>{
  const p0=player;
  const {player:pp}=ensureDaily(p0);
  if(pp.dailyQuestClaimed?.[key]) return showMessage("ì´ë¯¸ ìˆ˜ë ¹í•œ ë³´ìƒì…ë‹ˆë‹¤.","info");
  if(!isQuestDone(pp,key)) return showMessage("ì•„ì§ ì¡°ê±´ì„ ë‹¬ì„±í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.","error");
  const rw=pp.dailyQuest.missions[key].reward;
  const np={...pp};
  np.gold=(np.gold||0)+rw.gold;
  np.stones=(np.stones||0)+rw.stone;
  np.dailyQuestClaimed={...(np.dailyQuestClaimed||initDailyClaimed()),[key]:true};
  savePlayerData(np);
  showMessage(`ë³´ìƒ ìˆ˜ë ¹! +${rw.gold}G +ê°•í™”ì„ ${rw.stone}ê°œ`,"success");
};
const TrainingSelectModal = () => {
  if (!trainingOpen) return null;

  const enterTraining = (subj) => {
    setTrainingOpen(false);
    setCurrentSubject(subj);          // âœ… ì„ íƒ ê³¼ëª© ì €ì¥
    showMessage(`ğŸŒ² ìˆ˜ë ¨ì˜ ìˆ² ì…ì¥: ${subj}`, "success");

    // âœ… ì „íˆ¬ í™”ë©´ìœ¼ë¡œ ì´ë™ í›„ ëª¬ìŠ¤í„°/ë¬¸ì œ ì„¸íŒ…
    setView("battle");
    setCurrentQuestion(null);
    setTimeout(() => {
      // spawnMonsterê°€ ë‚´ë¶€ì—ì„œ pickQuestionì„ í˜¸ì¶œí•¨ (subjectëŠ” currentSubject ê¸°ë°˜)
spawnEnemy({ mode: "field", p: player, questionOverride: subj });
    }, 0);
  };

  return (
    <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-[999]">
      <div className="bg-slate-800 p-5 rounded-xl border border-emerald-500 w-[92vw] max-w-md shadow-2xl">
        <div className="flex items-center justify-between mb-3">
          <h2 className="text-lg font-bold text-emerald-300">ğŸŒ² ìˆ˜ë ¨ì˜ ìˆ² - ê³¼ëª© ì„ íƒ</h2>
          <button
            onClick={() => setTrainingOpen(false)}
            className="text-xs px-2 py-1 rounded bg-slate-700 hover:bg-slate-600 text-gray-100"
          >
            ë‹«ê¸°
          </button>
        </div>

        <div className="text-xs text-gray-300 mb-4">
          ì„ íƒí•œ ê³¼ëª©ìœ¼ë¡œ ë¬¸ì œê°€ ì¶œì œë©ë‹ˆë‹¤.
        </div>

        <div className="grid grid-cols-2 gap-2">
          {TRAINING_SUBJECTS.map((s) => (
            <button
              key={s}
              onClick={() => enterTraining(s)}
              className="py-3 rounded-lg font-bold bg-emerald-600 hover:bg-emerald-500 text-white border border-emerald-300/30"
            >
              {s}
            </button>
          ))}
        </div>

        <div className="mt-4 text-[11px] text-gray-400">
          â€¢ ESCë¡œ ë‹«ê³  ì‹¶ìœ¼ë©´ ë§í•´ì¤˜. ë°”ë¡œ ë¶™ì—¬ì¤„ê²Œ.
        </div>
      </div>
    </div>
  );
};

const QuestModal=()=>{
  if(!questOpen) return null;
  const p=player;
  const q=p.dailyQuest?.missions||{};
  const pr=p.dailyQuestProgress||initDailyProgress();
  const cl=p.dailyQuestClaimed||initDailyClaimed();

  const Row=({k,title,progressText,done})=>(
    <div className="bg-slate-900/40 border border-slate-700 rounded-lg p-3 flex items-center justify-between gap-3">
      <div className="min-w-0">
        <div className="font-bold text-sm text-white flex items-center gap-2">
          {done? <span className="text-green-400">âœ…</span> : <span className="text-gray-400">â¬œ</span>}
          <span className="truncate">{title}</span>
        </div>
        <div className="text-xs text-gray-300 mt-1">
          <span className="text-blue-300 font-mono">{progressText}</span>
          <span className="text-gray-500"> | </span>
          <span className="text-yellow-300">ë³´ìƒ {q[k]?.reward?.gold||0}G</span>
          <span className="text-gray-500"> + </span>
          <span className="text-purple-300">ê°•í™”ì„ {q[k]?.reward?.stone||0}</span>
        </div>
      </div>
      <div className="shrink-0">
        {done ? (cl[k] ? (
          <span className="text-xs px-2 py-1 rounded bg-slate-700 text-gray-200">ìˆ˜ë ¹ ì™„ë£Œ</span>
        ) : (
          <button onClick={()=>claimQuest(k)} className="text-xs px-3 py-2 rounded bg-green-600 hover:bg-green-500 text-white font-bold">ë³´ìƒ ë°›ê¸°</button>
        )) : (
          <span className="text-xs px-2 py-1 rounded bg-slate-700 text-gray-300">ì§„í–‰ì¤‘</span>
        )}
      </div>
    </div>
  );

  const doneKill=isQuestDone(p,"kill"), doneSt=isQuestDone(p,"streak"), doneBoss=isQuestDone(p,"boss");

  return (
    <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-[999]">
      <div className="bg-slate-800 p-5 rounded-xl border border-blue-500 w-[92vw] max-w-md shadow-2xl">
        <div className="flex items-center justify-between mb-3">
          <h2 className="text-lg font-bold text-blue-300">ğŸ“ ì˜¤ëŠ˜ì˜ í€˜ìŠ¤íŠ¸</h2>
          <button onClick={()=>setQuestOpen(false)} className="text-xs px-2 py-1 rounded bg-slate-700 hover:bg-slate-600 text-gray-100">ë‹«ê¸°</button>
        </div>

        <div className="text-[11px] text-gray-400 mb-3 flex justify-between">
          <span>ë‚ ì§œ: {p.dailyQuest?.date||todayKey()}</span>
          <span>ë³´ìœ  ê°•í™”ì„: <b className="text-purple-300">{p.stones||0}</b></span>
        </div>

        <div className="space-y-2">
          <Row k="kill" title={`ì˜¤ëŠ˜ ëª¬ìŠ¤í„° ${q.kill?.target||0}ë§ˆë¦¬ ì²˜ì¹˜`} progressText={`${pr.kills||0}/${q.kill?.target||0}`} done={doneKill}/>
          <Row k="streak" title={`ì—°ì† ì •ë‹µ ${q.streak?.target||0}íšŒ ë‹¬ì„±(ìµœê³ ê¸°ë¡)`} progressText={`${pr.streakBest||0}/${q.streak?.target||0} (í˜„ì¬ ${pr.streakCur||0})`} done={doneSt}/>
          <Row k="boss" title={`ë³´ìŠ¤ ${q.boss?.target||0}íšŒ í´ë¦¬ì–´`} progressText={`${pr.bossClears||0}/${q.boss?.target||0}`} done={doneBoss}/>
        </div>

        <div className="mt-4 text-[11px] text-gray-400">
          â€¢ ëª¬ìŠ¤í„° ì²˜ì¹˜: ì¼ë°˜/ì „ì„¤ ë˜ì „ ëª¬ìŠ¤í„° ì²˜ì¹˜ ì‹œ ì¦ê°€<br/>
          â€¢ ì—°ì† ì •ë‹µ: ì˜¤ë‹µ ì‹œ í˜„ì¬ ì—°ì†ì€ 0ìœ¼ë¡œ ë¦¬ì…‹, ìµœê³  ê¸°ë¡ì€ ìœ ì§€
        </div>
      </div>
    </div>
  );
};

      const getTotalHp=(p=player)=>p.baseMaxHp+(p.equippedArmor?.hp??0);
      const getTotalAtk=(p=player)=>{ let atk=p.baseAtk; if(p.equippedWeapon) atk+=p.equippedWeapon.atk; return atk; };

      const handleLogin=async()=>{ if(!loginName.trim()||!loginPw.trim()) return alert("ì…ë ¥ í•„ìš”"); setLoading(true);
        const customId=`${loginName.trim()}_${loginPw.trim()}`; setAccountId(customId); localStorage.setItem("last_login_name",loginName.trim());

const safeSetPlayer=(data)=>{
  let mergedPlayer = {...defaultPlayer, ...data};
  mergedPlayer.inventory = Array.isArray(mergedPlayer.inventory) ? mergedPlayer.inventory : [];
  mergedPlayer.solved = Array.isArray(mergedPlayer.solved) ? mergedPlayer.solved : [];
  mergedPlayer.fragments = mergedPlayer.fragments || {...defaultPlayer.fragments};
if(typeof mergedPlayer.towerFloor!=="number") mergedPlayer.towerFloor=1;
if(typeof mergedPlayer.towerCheckpoint!=="number") mergedPlayer.towerCheckpoint=1;
  const ensured = ensureDaily(mergedPlayer);
  mergedPlayer = ensured.player;
  setPlayer(mergedPlayer);
  return mergedPlayer;
};


        if(!db){
          const localData=localStorage.getItem("rpg_save_"+customId);
          try{ if(localData){ const p=safeSetPlayer(JSON.parse(localData)); showMessage(`(ë¡œì»¬) ${p.name}ë‹˜ í™˜ì˜í•©ë‹ˆë‹¤!`,"success"); }
            else { safeSetPlayer({name:loginName.trim()}); showMessage("(ë¡œì»¬) ìƒˆë¡œìš´ ëª¨í—˜ ì‹œì‘!","success"); }
          }catch(e){ safeSetPlayer({name:loginName.trim()}); }
          setView("lobby"); setLoading(false); return;
        }

        try{
          const docRef=db.collection("artifacts").doc(appId).collection("accounts").doc(customId);
          const docSnap=await docRef.get();
          if(docSnap.exists){ const p=safeSetPlayer(docSnap.data()); showMessage(`${p.name}ë‹˜, í™˜ì˜í•©ë‹ˆë‹¤!`,"success"); }
          else { const newPlayer={...defaultPlayer,name:loginName.trim()}; setPlayer(newPlayer); await docRef.set(newPlayer); showMessage("ìƒˆë¡œìš´ ëª¨í—˜ì„ ì‹œì‘í•©ë‹ˆë‹¤.","success"); }
          setView("lobby");
        }catch(e){ console.error(e); alert("ë¡œê·¸ì¸ ì˜¤ë¥˜ (ê¶Œí•œ/ë„¤íŠ¸ì›Œí¬ í™•ì¸)"); }
        setLoading(false);
      };

      const savePlayerData=async(newData)=>{ const totalAtk=getTotalAtk(newData); const dataToSave={...newData,totalAtk, // ğŸ”¥ ì¶”ê°€
      }; setPlayer(newData);
        if(db&&accountId) await db.collection("artifacts").doc(appId).collection("accounts").doc(accountId).set(dataToSave);
      };

      const getPrevRarity=(rarity)=>rarity==="Rare"?"Common":rarity==="Unique"?"Rare":rarity==="Legend"?"Unique":rarity==="Myth"?"Legend":null;
const getEnhanceCost = (item) => {
  // +20ê°•ë¶€í„°: 5000ê³¨ë“œ + ê°•í™”ì„ 1ê°œ
  if (item.enhanceLevel >= 20) return { gold: 5000, stone: 1 };

  // +10~+19: 5000ê³¨ë“œ(ê°•í™”ì„ ì—†ìŒ)
  if (item.enhanceLevel >= 10) return { gold: 3000, stone: 0 };

  // +0~+9: ê¸°ì¡´ ê³µì‹
  if (item.type === "weapon") return { gold: item.atk * 1, stone: 0 };
  if (item.type === "armor") return { gold: item.hp * 0.5, stone: 0 };
  return { gold: 0, stone: 0 };
};

      const FORGE_RULES={Rare:{need:10,keys:4},Unique:{need:10,keys:6},Legend:{need:10,keys:8},Myth:{need:10,keys:10}};
const forgeCandidates = (player.inventory || []).filter( i => i.type === "weapon" && !i.protected);      
const REQUIRED_COUNT=5;

      const toggleForgeSelect=(item)=>setForgeSelected(prev=>prev.includes(item.id)?prev.filter(id=>id!==item.id):(prev.length>=REQUIRED_COUNT?prev:[...prev,item.id]));
      const generateKeys=(count)=>{ const chars="asdfjkl"; let result=""; for(let i=0;i<count;i++) result+=chars[Math.floor(Math.random()*chars.length)]; return result; };

      const startForge=(rarity)=>{ const rule=FORGE_RULES[rarity];
        if(forgeSelected.length!==REQUIRED_COUNT){ showMessage(`ë¬´ê¸° ${REQUIRED_COUNT}ê°œê°€ í•„ìš”í•©ë‹ˆë‹¤`,"error"); return; }
        const items=(player.inventory||[]).filter(i=>forgeSelected.includes(i.id));
        // ğŸ”’ ë¬´ê¸°ë§Œ í—ˆìš©
        if(!items.every(i=>i.type==="weapon")){ showMessage("ë¬´ê¸°ë§Œ ì¡°í•©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤","error"); return; }
        // ğŸ”’ ê°™ì€ ë“±ê¸‰ì¸ì§€ ê²€ì‚¬
        const prevRarity=items[0]?.rarity; if(!items.every(i=>i.rarity===prevRarity)){ showMessage("ê°™ì€ ë“±ê¸‰ ë¬´ê¸°ë§Œ ì¡°í•© ê°€ëŠ¥í•©ë‹ˆë‹¤","error"); return; }
        // ğŸ”’ ëª©í‘œ ë“±ê¸‰ ê²€ì¦ (Rare â†’ Unique ë“±)
        if(prevRarity!==getPrevRarity(rarity)){ showMessage(`${prevRarity} â†’ ${rarity} ì¡°í•©ë§Œ ê°€ëŠ¥í•©ë‹ˆë‹¤`,"error"); return; }
        const keys=generateKeys(rule.keys);
        setForgeTargetRarity(rarity); setForgePhase("ready"); setForgeResult(null);
        setForgeMiniGame({keys,input:"",timeLeft:10000}); setTimeout(()=>setForgePhase("play"),5000);
      };

      const successForge=()=>{ clearTimeout(forgeTimerRef.current); setForgeResult("success"); setForgePhase("result");
        // ğŸ”½ 2ì´ˆê°„ ê²°ê³¼ ë³´ì—¬ì¤€ ë’¤ ë³´ìƒ ì ìš©
        setTimeout(()=>{ const newPlayer={...player};
          // ì‚¬ìš©í•œ ë¬´ê¸° 10ê°œ ì œê±°
          newPlayer.inventory=(newPlayer.inventory||[]).filter(i=>!forgeSelected.includes(i.id));
          // ìƒìœ„ ë¬´ê¸° ìƒì„±
          const rarity=forgeTargetRarity, range=ITEM_RANGES[rarity];
          const atk=Math.floor(Math.random()*(range.max-range.min+1))+range.min;
          newPlayer.inventory.push({id:Date.now(),name:`${rarity} ê²€`,rarity,atk,enhanceLevel:0,type:"weapon",value:range.price});
          savePlayerData(newPlayer); showMessage(`ğŸ”¥ ${rarity} ë¬´ê¸° ì œì‘ ì„±ê³µ!`,"success");
          setForgeSelected([]); setForgeMiniGame(null);     // âœ… ë¯¸ë‹ˆê²Œì„ ì¢…ë£Œ
          setForgePhase("ready");     // âœ… ë‹¤ìŒ ëŒ€ë¹„
          setForgeResult(null);
        },2000);
      };

      const failForge=()=>{ setForgeResult("fail"); setForgePhase("result");
        // ğŸ”½ 2ì´ˆê°„ ê²°ê³¼ ë³´ì—¬ì¤€ ë’¤ ì†ì‹¤ ì²˜ë¦¬
        setTimeout(()=>{ const selectedItems=(player.inventory||[]).filter(i=>forgeSelected.includes(i.id));
          const loseCount=Math.floor(REQUIRED_COUNT/2);
          const shuffled=[...selectedItems].sort(()=>Math.random()-0.5);
          const lostIds=shuffled.slice(0,loseCount).map(i=>i.id);
          const newInventory=(player.inventory||[]).filter(i=>!lostIds.includes(i.id));
          const newPlayer={...player,inventory:newInventory};
          savePlayerData(newPlayer); showMessage(`ğŸ’¥ ì¡°í•© ì‹¤íŒ¨! ë¬´ê¸° ${loseCount}ê°œê°€ íŒŒê´´ë˜ì—ˆìŠµë‹ˆë‹¤`,"error");
          setForgeSelected([]); setForgeMiniGame(null);     // âœ… ë¯¸ë‹ˆê²Œì„ ì¢…ë£Œ
          setForgePhase("ready");     // âœ… ë¦¬ì…‹
          setForgeResult(null);
        },2000);
      };

      const tryEnterBoss=()=>{ if(player.level<10){ showMessage("ğŸš« ë³´ìŠ¤ ë ˆì´ë“œëŠ” ë ˆë²¨ 10ë¶€í„° ì…ì¥ ê°€ëŠ¥í•©ë‹ˆë‹¤!","error"); return; }
        const required=["êµ­ì–´","ìˆ˜í•™","ì‚¬íšŒ","ê³¼í•™"];
        const missing=required.filter(subj=>(player.fragments[subj]||0)<BOSS_ENTRY_COST);
        if(missing.length>0){ showMessage(`ğŸš« ì¡°ê° ë¶€ì¡±! (${missing.join(", ")} ì¡°ê° ${BOSS_ENTRY_COST}ê°œ í•„ìš”)`,"error"); return; }
        const newFragments={...player.fragments}; required.forEach(subj=>newFragments[subj]-=BOSS_ENTRY_COST);
        const newPlayer={...player,fragments:newFragments}; setPlayer(newPlayer); savePlayerData(newPlayer); showMessage("âš¡ ì¡°ê°ì„ ì‚¬ìš©í•˜ì—¬ ë³´ìŠ¤ë°©ì— ì…ì¥í•©ë‹ˆë‹¤!","success");
        setView("boss");spawnEnemy({ mode: "boss", p: newPlayer });      };

      const tryEnterLegendDungeon=()=>{ if(player.level<40){ showMessage("ğŸš« ì „ì„¤ì˜ ë˜ì „ì€ ë ˆë²¨ 40ë¶€í„° ì…ì¥ ê°€ëŠ¥í•©ë‹ˆë‹¤!","error"); return; }
        showMessage("ğŸ° ì „ì„¤ì˜ ë˜ì „ì— ì…ì¥í•©ë‹ˆë‹¤! (ê°•ë ¥í•œ ëª¬ìŠ¤í„° ì£¼ì˜)","success"); setView("legend"); spawnEnemy({ mode: "legend", p: player });};
// ===== ê³µìš© í—¬í¼ =====
const rPick = (arr) => {
  const i = Math.floor(Math.random() * arr.length);
  return { i, v: arr[i] };
};

const clamp = (n, a, b) => Math.max(a, Math.min(b, n));

// ===== ëª¬ìŠ¤í„° í’€(ìŠ¤í™/í‘œì‹œìš©) =====
const MONSTER_POOLS = {
  field: {
    label: "",
    types: ["ê°„ì§€ ê°ì","ê°ë™ ê°ì","ë©”ë¡± ê°ì","ìš°ëŠ” ê°ì","ì›ƒëŠ” ê°ì","ì½”ì£¼ë¶€ ê°ì"],
    emojis: ["ğŸ¥”","ğŸ¥”","ğŸ¥”","ğŸ¥”","ğŸ¥”","ğŸ¥”"],
    imgs: FIELD_IMGS,
    hp: (lvl) => lvl * 12.5 + 10,
    atk: (lvl) => lvl * 2 + 5,
  },
  legend: {
    label: "[ì „ì„¤]",
    types: ["ë“œë˜ê³¤ ë‚˜ì´íŠ¸","ê³ ëŒ€ ì•…ë§ˆ","íƒ€ë½í•œ ì²œì‚¬","ì‹¬ì—°ì˜ ê°ì‹œì"],
    emojis: ["ğŸ‰","ğŸ˜ˆ","ğŸ‘¼","ğŸ‘ï¸"],
    imgs: LEGEND_IMGS,
    hp: (lvl) => (lvl * 12.5 + 10) * 3,
    atk: (lvl) => (lvl * 2 + 5) * 2,
  },
  tower: {
    label: "[ì‹œë ¨]",
    types: ["íƒ‘ì˜ ìˆ˜í˜¸ì","ê´‘ê¸°ì˜ ê¸°ì‚¬","ì‹¬ì—°ì˜ ë§ë ¹","ì €ì£¼ë°›ì€ ê°ì‹œì"],
    emojis: ["ğŸ—¿","âš”ï¸","ğŸ‘»","ğŸ‘ï¸"],
    imgs: TOWER_IMGS,
    // íƒ‘ì€ ì „ì„¤ ìŠ¤ì¼€ì¼ì„ ë” ì¦í­(ê¸°ì¡´ ë¡œì§ ìœ ì§€)
    hp: (lvl) => Math.floor(((lvl * 12.5 + 10) * 3) * 3),
    atk: (lvl) => Math.floor(((lvl * 2 + 5) * 2) * 5),
  },
};
// âœ… ëª¨ë“  ì „íˆ¬(í•„ë“œ/ì „ì„¤/ë³´ìŠ¤/íƒ‘) ëª¬ìŠ¤í„° ìŠ¤í° í†µí•©
const spawnEnemy = ({
  mode = "field",           // "field" | "legend" | "boss" | "tower"
  p = player,               // ê¸°ì¤€ í”Œë ˆì´ì–´
  floor = null,             // towerì¼ ë•Œ ì¸µ
  questionOverride = null,  // training ë“± ê³¼ëª© ê°•ì œ
} = {}) => {
  setIsRespawning(false);

  // ----- ë³´ìŠ¤ -----
  if (mode === "boss") {
    const lvl = p.level || 1;
    setBossStreak(0);

    setMonster({
      name: `[BOSS] Lv.${lvl} ê°ìì˜ ì§€ë°°ì`,
      level: lvl,
      hp: 10000,
      maxHp: 10000,
      atk: 999,
      image: BOSS_IMG || null,
      emoji: "ğŸ¥”",
    });

    pickQuestion(true, null, p.solved);
    return;
  }

  // ----- í•„ë“œ/ì „ì„¤/íƒ‘ -----
  const isTower = mode === "tower";
  const lvl = isTower ? Number(floor || 1) : (p.level || 1);

  const pool = MONSTER_POOLS[mode] || MONSTER_POOLS.field;
  const { i: idx, v: typeName } = rPick(pool.types);

  const emoji = pool.emojis?.[idx] || "ğŸ¥”";
  const image = (pool.imgs?.[idx]) || null;

  const name = isTower
    ? `${pool.label} ${lvl}F ${typeName}`
    : `${pool.label} Lv.${lvl} ${typeName}`.trim();

  const hp = pool.hp(lvl);
  const atk = pool.atk(lvl);

  setMonster({
    name,
    level: lvl,
    hp,
    maxHp: hp,
    atk,
    image,
    emoji,
  });

  // ê³¼ëª© ê²°ì •(ê¸°ì¡´ pickQuestion ê·œì¹™ì„ ê·¸ëŒ€ë¡œ í™œìš©)
  const subject =
    isTower ? towerSubjectFor(lvl)
    : questionOverride || null; // legendëŠ” nullë¡œ ë‘ë©´ pickQuestionì—ì„œ view==="legend"ì¼ ë•Œ ëœë¤ ì²˜ë¦¬ ìœ ì§€

  pickQuestion(false, subject, p.solved);
};


const enterTower = () => {
  if ((player.level || 0) < 50) {
    showMessage("ğŸš« ì‹œë ¨ì˜ íƒ‘ì€ ë ˆë²¨ 50ë¶€í„° ì…ì¥ ê°€ëŠ¥í•©ë‹ˆë‹¤!", "error");
    return;};

  const f = Number(player.towerFloor || 1);
  const cp = Number(player.towerCheckpoint || 1);

  setTowerFloor(f);
  setTowerCheckpoint(cp);
  setView("tower");

  // íœ´ì‹ì¸µì´ë©´ íœ´ì‹ í™”ë©´, ì „íˆ¬ì¸µì´ë©´ ëª¬ìŠ¤í„° ìŠ¤í°
  startTowerFloor(f, player, cp);
};

const startTowerFloor = (floor, p0=player, cp0=towerCheckpoint) => {
  const f = Math.max(1, Math.min(TOWER_MAX_FLOOR, floor));
  const isRest = TOWER_REST_FLOORS.includes(f);

  // ì €ì¥í¬ì¸íŠ¸ ê°±ì‹ (1/20/40/60/80 ë„ë‹¬ ì‹œ)
  const newCp = (TOWER_SAVE_FLOORS.includes(f)) ? f : cp0;

  setTowerFloor(f);
  setTowerCheckpoint(newCp);

  // í”Œë ˆì´ì–´ì—ë„ ì €ì¥(ì´ì–´í•˜ê¸°ìš©)
  const p = {
    ...p0,
    towerFloor: f,
    towerCheckpoint: newCp,
  };

  // íœ´ì‹ì¸µ: íšŒë³µ + ëª¬ìŠ¤í„°/ë¬¸ì œ ì—†ìŒ
  if(isRest){
    const fullHp = getTotalHp(p);
    p.maxHp = fullHp;
    p.hp = fullHp;
    savePlayerData(p);
    setMonster(null);
    setCurrentQuestion(null);
    setIsRespawning(false);
    return;
  }

  // ì „íˆ¬ì¸µ
spawnEnemy({ mode: "tower", p, floor: f });
};


      const pickQuestion=(isBoss=false,specificSubject=null,solvedOverride=null)=>{ let subject=specificSubject||currentSubject; if(isBoss) subject="ë³´ìŠ¤"; if(view==="legend") subject=["êµ­ì–´","ìˆ˜í•™","ì‚¬íšŒ","ê³¼í•™","ìƒì‹"][Math.floor(Math.random()*5)];
        const safeQuestions=questions.length>0?questions:MOCK_QUESTIONS;
        let subjectQuestions=safeQuestions.filter(q=>q.subject===subject);
        if(isBoss&&subjectQuestions.length===0){ if(safeQuestions.some(q=>q.subject==="ë³´ìŠ¤")){} else subjectQuestions=safeQuestions; }
        if(subjectQuestions.length===0) subjectQuestions=safeQuestions;
        const solvedList=solvedOverride||player.solved||[];
        let unsolvedQuestions=subjectQuestions.filter(q=>!solvedList.includes(q.id));
        if(unsolvedQuestions.length===0){
          if(!isBoss&&view!=="legend") showMessage(`${subject} ê³¼ëª© ë¬¸ì œ ë¦¬ì…‹! ë‹¤ì‹œ ì‹œì‘í•©ë‹ˆë‹¤.`,"info");
          const subjectIds=subjectQuestions.map(q=>q.id);
          const resetSolvedList=solvedList.filter(id=>!subjectIds.includes(id));
          const newPlayer={...player,solved:resetSolvedList}; setPlayer(newPlayer); savePlayerData(newPlayer);
          unsolvedQuestions=subjectQuestions;
        }
        const q=unsolvedQuestions.length>0?unsolvedQuestions[Math.floor(Math.random()*unsolvedQuestions.length)]:safeQuestions[0];
        setCurrentQuestion(q);
      };

      const tryDropFragment=(playerToUpdate,subject)=>{if (view === "tower") return; if(subject==="ë³´ìŠ¤"||subject==="ìƒì‹") return;
        // [ìˆ˜ì •] ì „ì„¤ ë˜ì „ì—ì„œë„ ì¡°ê° ë“œë¡­ (í™•ë¥  50%)
        let rate=FRAGMENT_DROP_RATE; if(view==="legend") rate=0.5;
        if(Math.random()<rate){ const newFragments={...playerToUpdate.fragments}; newFragments[subject]=(newFragments[subject]||0)+1; playerToUpdate.fragments=newFragments; showMessage(`ğŸ§© [${subject}ì˜ ì¡°ê°]ì„ íšë“í–ˆìŠµë‹ˆë‹¤!`,"success"); }
      };
const tryDropStone = (playerToUpdate) => {
  if (view !== "tower") return; // âœ… íƒ‘ì—ì„œë§Œ ë“œë¡­
  if (Math.random() < STONE_DROP_RATE) {
    playerToUpdate.stones = (playerToUpdate.stones || 0) + 1;
    showMessage("ğŸª¨ ê°•í™”ì„ 1ê°œë¥¼ íšë“í–ˆìŠµë‹ˆë‹¤!", "success");
  }
};
const tryDropItem = (playerToUpdate) => {
  const roll = Math.random();
  let rarity = null;

  // âœ… ì‹œë ¨ì˜ íƒ‘
  if (view === "tower") {
    if (roll < TOWER_DROP_RATES.Myth) rarity = "Myth";
    else if (roll < TOWER_DROP_RATES.Myth + TOWER_DROP_RATES.Legend) rarity = "Legend";
    else if (roll < TOWER_DROP_RATES.Myth + TOWER_DROP_RATES.Legend + TOWER_DROP_RATES.Unique) rarity = "Unique";
    // ë‚˜ë¨¸ì§€: ë“œë¡­ ì—†ìŒ

  // âœ… ì „ì„¤ì˜ ë˜ì „
  } else if (view === "legend") {
    if (roll < LEGEND_DROP_RATES.Legend) rarity = "Legend";
    else if (roll < LEGEND_DROP_RATES.Legend + LEGEND_DROP_RATES.Unique) rarity = "Unique";
    else if (roll < LEGEND_DROP_RATES.Legend + LEGEND_DROP_RATES.Unique + LEGEND_DROP_RATES.Rare) rarity = "Rare";
    // ë‚˜ë¨¸ì§€: ë“œë¡­ ì—†ìŒ (Myth ì—†ìŒ)

  // âœ… ìˆ˜ë ¨ì˜ ìˆ²(=ì¼ë°˜ í•„ë“œ)
  } else {
    if (roll < RARITY_RATES.Unique) rarity = "Unique";
    else if (roll < RARITY_RATES.Unique + RARITY_RATES.Rare) rarity = "Rare";
    else if (roll < RARITY_RATES.Unique + RARITY_RATES.Rare + RARITY_RATES.Common) rarity = "Common";
    // ë‚˜ë¨¸ì§€: ë“œë¡­ ì—†ìŒ (Legend/Myth ì—†ìŒ)
  }

  if (rarity) {
    const range = ITEM_RANGES[rarity];
    const isArmor = Math.random() < 0.1; // 10% í™•ë¥ ë¡œ ê°‘ì˜·
    let newItem;

    if (isArmor) {
      newItem = { id: Date.now() + Math.random(), name: `${rarity} ê°‘ì˜·`, rarity, hp: ARMOR_BASE_HP[rarity], value: range.price, enhanceLevel: 0, type: "armor" };
    } else {
      const atk = Math.floor(Math.random() * (range.max - range.min + 1)) + range.min;
      newItem = { id: Date.now() + Math.random(), name: `${rarity} ê²€`, rarity, atk, value: range.price, enhanceLevel: 0, type: "weapon" };
    }

    playerToUpdate.inventory.push(newItem);
    showMessage(`[${rarity}] ì•„ì´í…œ íšë“!`, "success");
  }
};
// âœ… ë³´ìŠ¤ í´ë¦¬ì–´ ì¡°ê±´(ë ˆë²¨ êµ¬ê°„ë³„ í•„ìš” ì—°ì† ì •ë‹µ ìˆ˜)
// 10~19:10, 20~29:11, 30~39:12 ... ê³„ì† ì¦ê°€
const getBossNeed = (lvl) => {
  const base = 10;
  if (lvl < 10) return base;
  return base + Math.max(0, Math.floor((lvl - 10) / 10));
};

const dropBossReward = (playerToUpdate, lvl = (playerToUpdate.level||1)) => {
  let rarity;

  if (lvl <= 30) {
    rarity = "Unique";
  } else if (lvl < 100) {   // âœ… 31~99
    rarity = "Legend";
  } else {
    // âœ… ê¸°ì¡´ ë³´ìŠ¤ ë³´ìƒ í™•ë¥  ìœ ì§€
    const roll = Math.random();
    if (roll < 0.005) rarity = "Myth";
    else if (roll < 0.05) rarity = "Legend";
    else rarity = "Unique";
  }

  const range = ITEM_RANGES[rarity];
  const atk = Math.floor(Math.random() * (range.max - range.min + 1)) + range.min;

  const newItem = {
    id: Date.now().toString(),
    name: `ê°ì ìŠ¬ë ˆì´ì–´ (${rarity})`,
    rarity,
    atk,
    value: range.price * 2,
    enhanceLevel: 0,
    type: "weapon"
  };

  playerToUpdate.inventory.push(newItem);
  showMessage(`ë³´ìŠ¤ ë³´ìƒ: ${newItem.name} íšë“!`, "success");
};


const handleAnswer = (idx) => {
  if (wrongAnswerModal) return;
  if (!monster || !currentQuestion || isRespawning) return;

  // âœ… ì˜¤ëŠ˜ í€˜ìŠ¤íŠ¸ í•„ë“œ ë³´ì •
  const ensured = ensureDaily(player);
  const baseP = ensured.player;
  if (ensured.changed) setPlayer(baseP);

  // âœ… newPlayerëŠ” baseP ê¸°ì¤€ìœ¼ë¡œ ë³µì‚¬
  const newPlayer = {
    ...baseP,
    inventory: [...(baseP.inventory || [])],
    solved: [...(baseP.solved || [])],
    fragments: { ...(baseP.fragments || {}) },
    dailyQuest: baseP.dailyQuest,
    dailyQuestProgress: { ...(baseP.dailyQuestProgress || initDailyProgress()) },
    dailyQuestClaimed: { ...(baseP.dailyQuestClaimed || initDailyClaimed()) },
    stones: (typeof baseP.stones === "number") ? baseP.stones : 0,
  };

  const isCorrect = idx === currentQuestion.answer;
  let logMsg = "";

  // âœ… ì—°ì†ì •ë‹µ ê°±ì‹ (ì¼ì¼í€˜)
  if (isCorrect) {
    newPlayer.dailyQuestProgress.streakCur = (newPlayer.dailyQuestProgress.streakCur || 0) + 1;
    newPlayer.dailyQuestProgress.streakBest = Math.max(
      newPlayer.dailyQuestProgress.streakBest || 0,
      newPlayer.dailyQuestProgress.streakCur || 0
    );
  } else {
    newPlayer.dailyQuestProgress.streakCur = 0;
  }

  // =========================
  // âœ… ì •ë‹µ ì²˜ë¦¬
  // =========================
  if (isCorrect) {
    // solved ê¸°ë¡
    if (currentQuestion.id !== undefined && !newPlayer.solved.includes(currentQuestion.id)) {
      newPlayer.solved.push(currentQuestion.id);
    }

    // âœ… ë³´ìŠ¤ëŠ” ë³„ë„ ì²˜ë¦¬ í›„ ì¢…ë£Œ(return)
    if (view === "boss") {
      const need = getBossNeed(newPlayer.level);
      const newStreak = bossStreak + 1;
      setBossStreak(newStreak);

      logMsg = `ì •ë‹µ! (${newStreak}/${need})`;

      if (newStreak >= need) {
        logMsg = "ë³´ìŠ¤ í† ë²Œ ì„±ê³µ!";
        dropBossReward(newPlayer, newPlayer.level);

        // âœ… ì¼ì¼í€˜ ë³´ìŠ¤ í´ë¦¬ì–´ +1
        newPlayer.dailyQuestProgress.bossClears =
          (newPlayer.dailyQuestProgress.bossClears || 0) + 1;

        setMonster(null);
        setView("lobby");
      } else {
        pickQuestion(true, null, newPlayer.solved);
      }

      setBattleLog((prev) => [logMsg, ...prev].slice(0, 5));
      savePlayerData(newPlayer);
      return; // âœ… bossë§Œ return
    }

    // âœ… ì¼ë°˜/ì „ì„¤/íƒ‘ ì „íˆ¬ (ì •ë‹µ = í”Œë ˆì´ì–´ ê³µê²©)
    const isCrit = Math.random() < 0.2;
    let dmg = getTotalAtk(newPlayer);
    if (isCrit) {
      dmg *= 2;
      logMsg = `í¬ë¦¬í‹°ì»¬! ${dmg} í”¼í•´!`;
    } else {
      logMsg = `ì •ë‹µ! ${dmg} í”¼í•´.`;
    }

    const newMonsterHp = monster.hp - dmg;

    // âœ… ì•„ì´í…œ/ì¡°ê° ë“œë¡­ ì‹œë„(ê¸°ì¡´ ë¡œì§ ìœ ì§€)
    tryDropItem(newPlayer);
    tryDropFragment(newPlayer, currentQuestion.subject);

    // âœ… ëª¬ìŠ¤í„° ì²˜ì¹˜
    if (newMonsterHp <= 0) {
      // âœ… ì¼ì¼í€˜ ì²˜ì¹˜ +1
      newPlayer.dailyQuestProgress.kills = (newPlayer.dailyQuestProgress.kills || 0) + 1;

      const rewardMultiplier = view === "legend" ? 3 :  view === "tower"  ? 5 : 1;
      const expGain = (20 + (newPlayer.level * 10)) * rewardMultiplier;
      const goldGain = ((Math.floor(Math.random() * 50) + 10) * 3) * rewardMultiplier;

      newPlayer.exp += expGain;
      newPlayer.gold += goldGain;
      logMsg = `ì²˜ì¹˜! +${expGain}XP +${goldGain}G`;

      // âœ… ë ˆë²¨ì—…
      if (newPlayer.exp >= newPlayer.maxExp) {
        newPlayer.level += 1;
        newPlayer.exp -= newPlayer.maxExp;
        newPlayer.maxExp = Math.floor(newPlayer.maxExp * 1.1);
        newPlayer.baseMaxHp += 20;
        newPlayer.maxHp = getTotalHp(newPlayer);
        newPlayer.hp = newPlayer.maxHp;
        newPlayer.baseAtk += 3;
        logMsg += " âœ¨ ë ˆë²¨ ì—…!";
      }

     // âœ… ì‹œë ¨ì˜ íƒ‘: ë‹¤ìŒ ì¸µ ì²˜ë¦¬
if (view === "tower") {
  tryDropStone(newPlayer);
  const next = towerFloor + 1;

  if (next > TOWER_MAX_FLOOR) {
    // âœ… 100ì¸µ í´ë¦¬ì–´ ë³´ìƒ: ì—‘ìŠ¤ì¹¼ë¦¬ë²„(ì‹ í™”) ATK 5000 ê³ ì •
    const excalibur = {
      id: (Date.now() + Math.random()).toString(),
      name: "ì—‘ìŠ¤ì¹¼ë¦¬ë²„",
      rarity: "Myth",
      atk: 5000,
      value: (ITEM_RANGES?.Myth?.price || 50000) * 2, // íŒë§¤ê°€(ì›í•˜ë©´ ì¡°ì •)
      enhanceLevel: 0,
      type: "weapon",
    };
    newPlayer.inventory.push(excalibur);
    showMessage("ğŸ† 100ì¸µ í´ë¦¬ì–´ ë³´ìƒ! [ì—‘ìŠ¤ì¹¼ë¦¬ë²„] íšë“!", "success");

    logMsg = "ğŸ‰ ì‹œë ¨ì˜ íƒ‘ 100ì¸µ í´ë¦¬ì–´! ì—‘ìŠ¤ì¹¼ë¦¬ë²„ íšë“!";
    newPlayer.towerFloor = 1;
    newPlayer.towerCheckpoint = 1;

    setMonster(null);
    setView("lobby");

    setBattleLog((prev) => [logMsg, ...prev].slice(0, 5));
    savePlayerData(newPlayer);
    return;
  } else {
    setMonster(null);
    setIsRespawning(true);
    setTimeout(() => startTowerFloor(next, newPlayer, newPlayer.towerCheckpoint), 1200);
    newPlayer.towerFloor = next;

    setBattleLog((prev) => [logMsg, ...prev].slice(0, 5));
    savePlayerData(newPlayer);
    return;
  }
}

      // âœ… ì¼ë°˜/ì „ì„¤: ë¦¬ìŠ¤í°
      setMonster(null);
      setIsRespawning(true);
      setTimeout(() => {spawnEnemy({ mode: (view === "legend" ? "legend" : "field"), p: newPlayer });}, 1500);
    } else {
      // âœ… ìƒì¡´: ëª¬ìŠ¤í„° HP ê°±ì‹  + ë‹¤ìŒ ë¬¸ì œ
      setMonster({ ...monster, hp: newMonsterHp });
      pickQuestion(false, view === "legend" ? "LEGEND" : null, newPlayer.solved);
    }

    setBattleLog((prev) => [logMsg, ...prev].slice(0, 5));
    savePlayerData(newPlayer);
    return;
  }

  // =========================
  // âœ… ì˜¤ë‹µ ì²˜ë¦¬
if (view === "boss") {
  // ë³´ìŠ¤ëŠ” ì˜¤ë‹µ ì¦‰ì‹œ í‡´ì¥(ì›ë˜ ê·œì¹™)
  setBossStreak(0);

  logMsg = "âŒ ë³´ìŠ¤ì „ ì˜¤ë‹µ! ë¡œë¹„ë¡œ í‡´ì¥í•©ë‹ˆë‹¤.";
  setWrongAnswerModal(`ì •ë‹µì€ "${currentQuestion.options[currentQuestion.answer]}" ì…ë‹ˆë‹¤.`);

  setMonster(null);
  setView("lobby");

  setBattleLog((prev) => [logMsg, ...prev].slice(0, 5));
  savePlayerData(newPlayer);
  return;
}
  // =========================
  const wrongMul =
    view === "tower" ? 3 :
    view === "legend" ? 2 :
    1.2;

  const dmg = Math.floor(monster.atk * wrongMul);
  newPlayer.hp -= dmg;
  logMsg = `ì˜¤ë‹µ... ${dmg} í”¼í•´.`;
  setWrongAnswerModal(`ì •ë‹µì€ "${currentQuestion.options[currentQuestion.answer]}" ì…ë‹ˆë‹¤.`);

  // âœ… ì‚¬ë§ ì²˜ë¦¬
  if (newPlayer.hp <= 0) {
    // âœ… ì‹œë ¨ì˜ íƒ‘ ì‚¬ë§
    if (view === "tower") {
      tryDropItem(newPlayer);
      tryDropFragment(newPlayer, currentQuestion.subject);

      const back = towerCheckpointFor(towerFloor);

      const fullHp = getTotalHp(newPlayer);
      newPlayer.maxHp = fullHp;
      newPlayer.hp = fullHp;

      newPlayer.towerFloor = back;
      newPlayer.towerCheckpoint = back;

      logMsg = `ğŸ’€ ì‚¬ë§! ${towerFloor}ì¸µ â†’ ì €ì¥í¬ì¸íŠ¸ ${back}ì¸µìœ¼ë¡œ í›„í‡´`;

      setMonster(null);
      setCurrentQuestion(null);
      setIsRespawning(false);

      setTowerFloor(back);
      setTowerCheckpoint(back);
      setView("tower");

      setBattleLog((prev) => [logMsg, ...prev].slice(0, 5));
      savePlayerData(newPlayer);

      startTowerFloor(back, newPlayer, back);
      return;
    }

    // âœ… ì¼ë°˜/ì „ì„¤ ì‚¬ë§: ê³¨ë“œ ì ˆë°˜ ì†Œì‹¤ + ë¡œë¹„
    newPlayer.hp = newPlayer.maxHp;
    const lostGold = Math.floor(newPlayer.gold * 0.5);
    newPlayer.gold -= lostGold;

    logMsg = "ì‚¬ë§... ê³¨ë“œ ì ˆë°˜ ì†Œì‹¤.";
    setMonster(null);
    setView("lobby");
  } else {
    // âœ… ìƒì¡´: ë‹¤ìŒ ë¬¸ì œ
    pickQuestion(view === "boss" || view === "legend", view === "legend" ? "LEGEND" : null, newPlayer.solved);
  }

  setBattleLog((prev) => [logMsg, ...prev].slice(0, 5));
  savePlayerData(newPlayer);
};




      const sellItem = (itemId) => {
  const idx = (player.inventory || []).findIndex(i => i.id === itemId);
  if (idx === -1) return;

  const item = (player.inventory || [])[idx];
  if (item?.protected) {
    showMessage("ğŸ”’ ë³´í˜¸ëœ ì¥ë¹„ëŠ” íŒë§¤í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.", "error");
    return;
  }

  const newPlayer = { ...player, inventory: [...player.inventory] };
  const target = newPlayer.inventory[idx]; // âœ… ì´ë¦„ ë³€ê²½

  if (newPlayer.equippedWeapon?.id === itemId) newPlayer.equippedWeapon = null;
  if (newPlayer.equippedArmor?.id === itemId) newPlayer.equippedArmor = null; // âœ… ê°‘ì˜·ë„ ì•ˆì „í•˜ê²Œ

  newPlayer.gold += target.value;
  newPlayer.inventory.splice(idx, 1);

  savePlayerData(newPlayer);
  showMessage(`íŒë§¤ ì™„ë£Œ +${target.value}G`, "success");
};


      const equipItem=(item)=>{ const newPlayer={...player};
        if(item.type==="weapon") newPlayer.equippedWeapon=item;
        if(item.type==="armor"){ const oldTotalHp=getTotalHp(newPlayer); newPlayer.equippedArmor=item;
          const newTotalHp=getTotalHp(newPlayer), diff=newTotalHp-oldTotalHp;
          newPlayer.hp=Math.min(newPlayer.hp+diff,newTotalHp); newPlayer.maxHp=newTotalHp;
        }
        savePlayerData(newPlayer);
      };

   const enhanceItem = (item, bonusRate = 0) => {
  if (item.enhanceLevel >= 99) return showMessage("ìµœëŒ€ ê°•í™” ìƒíƒœ", "info");

  const cost = getEnhanceCost(item); // {gold, stone}
  const baseRate = item.enhanceLevel >= 10 ? 0.1 : ENHANCE_RATES[item.enhanceLevel];
  const successRate = Math.min(0.95, baseRate + bonusRate); // âœ… ë³´ë„ˆìŠ¤ ì ìš©(ìµœëŒ€ 95% ìº¡)

  // âœ… ì¬í™” ì²´í¬
  if (player.gold < cost.gold) return showMessage("ê³¨ë“œ ë¶€ì¡±!", "error");
  if ((cost.stone || 0) > 0 && (player.stones || 0) < cost.stone) {
    return showMessage("ê°•í™”ì„ ë¶€ì¡±!", "error");
  }

  // âœ… ì¬í™” ì°¨ê° (ê³¨ë“œ + ê°•í™”ì„)
  const newPlayer = {
    ...player,
    inventory: [...player.inventory],
    gold: player.gold - cost.gold,
    stones: (player.stones || 0) - (cost.stone || 0),
  };

  const target = newPlayer.inventory.find(i => i.id === item.id);
  if (!target) return;

  if (Math.random() < successRate) {
    if (target.type === "weapon") {
      const inc = Math.floor(target.atk * 0.1);
      target.atk += inc;
    }
    if (target.type === "armor") {
      const inc = Math.floor(target.hp * 0.1);
      target.hp += inc;

      if (newPlayer.equippedArmor?.id === target.id) {
        const oldTotalHp = newPlayer.maxHp;
        const newTotalHp = getTotalHp(newPlayer);
        newPlayer.maxHp = newTotalHp;
        newPlayer.hp = Math.min(newPlayer.hp + (newTotalHp - oldTotalHp), newTotalHp);
      }
    }

    target.enhanceLevel += 1;

    // âœ… ë©”ì‹œì§€ì— í™•ë¥  í‘œì‹œ(10ê°• ì´ìƒì—ì„œë§Œ ìŠ¤íƒ€ìºì¹˜ ë³´ë„ˆìŠ¤ê°€ ì˜ë¯¸ ìˆìŒ)
    if (target.enhanceLevel >= 10) {
      showMessage(`ê°•í™” ì„±ê³µ! +${target.enhanceLevel} (í™•ë¥  ${(successRate*100).toFixed(0)}%)`, "success");
    } else {
      showMessage(`ê°•í™” ì„±ê³µ! +${target.enhanceLevel}`, "success");
    }
  } else {
    if (target.enhanceLevel >= 10) {
      showMessage(`ê°•í™” ì‹¤íŒ¨... (í™•ë¥  ${(successRate*100).toFixed(0)}%)`, "error");
    } else {
      showMessage("ê°•í™” ì‹¤íŒ¨...", "error");
    }
  }

  if (newPlayer.equippedWeapon?.id === target.id) newPlayer.equippedWeapon = target;
  if (newPlayer.equippedArmor?.id === target.id) newPlayer.equippedArmor = target;

  savePlayerData(newPlayer);
};


      // âœ… ì•„ì´í…œ ì •ë ¬ ìš°ì„ ìˆœìœ„
      const RARITY_ORDER={Myth:0,Legend:1,Unique:2,Rare:3,Common:4};

      // idê°€ number/string/float ì„ì—¬ë„ "ìµœì‹ " ë¹„êµê°€ ë˜ê²Œ ë³€í™˜
      const getCreatedKey=(id)=>{ if(typeof id==="number") return id; // Date.now() or Date.now()+Math.random
        if(typeof id==="string"){ const n=parseInt(id,10); return Number.isFinite(n)?n:0; } return 0;
      };

      // âœ… í˜„ì¬ íƒ­ ê¸°ì¤€ìœ¼ë¡œ "ì¥ì°©ì¤‘(E)" íŒë³„ (ë¬´ê¸°íƒ­ì´ë©´ ë¬´ê¸°ë§Œ, ê°‘ì˜·íƒ­ì´ë©´ ê°‘ì˜·ë§Œ)
      const isEquippedItem=(item,p=player)=>{ if(item.type==="weapon") return p.equippedWeapon?.id===item.id; if(item.type==="armor") return p.equippedArmor?.id===item.id; return false; };

      // âœ… comparator (ì •ë ¬ ëª¨ë“œ: rarity / stat)
      const makeCompareItems=(p,sortMode)=>(a,b)=>{
        // 0) ì¥ì°©í…œ ìµœìƒë‹¨ ê³ ì •
        const ae=isEquippedItem(a,p)?0:1, be=isEquippedItem(b,p)?0:1; if(ae!==be) return ae-be;
        // 1) ë“±ê¸‰ë³„
        if(sortMode==="rarity"){ const ar=RARITY_ORDER[a.rarity]??9, br=RARITY_ORDER[b.rarity]??9; if(ar!==br) return ar-br;
          // ê°™ì€ ë“±ê¸‰ì´ë©´ "ìµœì‹ ì€ ì•„ë˜" (ì˜¤ë˜ëœê²Œ ìœ„)
          return getCreatedKey(a.id)-getCreatedKey(b.id);
        }
        // 2) ìŠ¤íƒ¯ë³„ (ë¬´ê¸°=ATK, ê°‘ì˜·=HP)
        const aStat=a.type==="weapon"?(a.atk??0):(a.hp??0), bStat=b.type==="weapon"?(b.atk??0):(b.hp??0);
        if(aStat!==bStat) return bStat-aStat; // ë†’ì€ ìŠ¤íƒ¯ì´ ìœ„
        // ìŠ¤íƒ¯ ê°™ìœ¼ë©´ ë“±ê¸‰
        const ar=RARITY_ORDER[a.rarity]??9, br=RARITY_ORDER[b.rarity]??9; if(ar!==br) return ar-br;
        // ë™ìˆœìœ„ ìµœì‹ ì€ ì•„ë˜
        return getCreatedKey(a.id)-getCreatedKey(b.id);
      };

      const renderInventory=(isEnhance)=>{
        const inv=player.inventory||[], frags=player.fragments||{};
        // âœ… íƒ­ í•„í„° (ë¬´ê¸°/ê°‘ì˜·ë§Œ)
        const filtered=inv.filter(item=>item.type===invTab);
        // âœ… ì •ë ¬ ì ìš©(ì¥ì°©í…œ ê³ ì • í¬í•¨)
        const sorted=[...filtered].sort(makeCompareItems(player,invSort));
        return (
          <div className="space-y-3">
            {/* âœ… (ì¸ë²¤ì—ì„œë§Œ) ì¡°ê° í‘œì‹œ */}
            {!isEnhance&&(
              <div className="bg-slate-800 p-2 rounded mb-2 border border-blue-500/30 text-xs">
                <h3 className="font-bold mb-1 text-blue-300">ğŸ§© ê³¼ëª© ì¡°ê° (ë³´ìŠ¤ ì…ì¥ë£Œ: {BOSS_ENTRY_COST}ê°œ)</h3>
                <div className="grid grid-cols-2 gap-1"><div>êµ­ì–´: {frags["êµ­ì–´"]||0}</div><div>ìˆ˜í•™: {frags["ìˆ˜í•™"]||0}</div><div>ì‚¬íšŒ: {frags["ì‚¬íšŒ"]||0}</div><div>ê³¼í•™: {frags["ê³¼í•™"]||0}</div></div>
              </div>
            )}

            {/* âœ… íƒ­ + ì •ë ¬ UI (ë¬´ê¸°/ê°‘ì˜·ë§Œ) */}
            <div className="bg-slate-800 p-2 rounded border border-slate-700 flex items-center gap-2 justify-between">
              <div className="flex gap-1">{[{key:"weapon",label:"ë¬´ê¸°"},{key:"armor",label:"ê°‘ì˜·"}].map(t=>(
                <button key={t.key} onClick={()=>setInvTab(t.key)} className={`px-2 py-1 rounded text-xs border transition ${invTab===t.key?"bg-blue-700 border-blue-400 text-white":"bg-slate-900/40 border-slate-600 text-gray-300 hover:bg-slate-700"}`}>{t.label}</button>
              ))}</div>
              <div className="flex items-center gap-2">
                <span className="text-[11px] text-gray-400">ì •ë ¬</span>
                <select value={invSort} onChange={(e)=>setInvSort(e.target.value)} className="bg-slate-900/50 border border-slate-600 text-xs rounded px-2 py-1 text-gray-200">
                  <option value="rarity">ë“±ê¸‰ë³„(ì‹ í™”â†’ì»¤ë¨¼)</option><option value="stat">ìŠ¤íƒ¯ë³„(ATK/HP)</option>
                </select>
              </div>
            </div>

            {/* âœ… ë¦¬ìŠ¤íŠ¸ */}
            {sorted.length===0?(
              <div className="text-center text-gray-500 py-10">í‘œì‹œí•  ì•„ì´í…œì´ ì—†ìŠµë‹ˆë‹¤.</div>
            ):sorted.map(item=>(
<div
  key={item.id}
  className="bg-slate-700/50 p-2 rounded flex justify-between items-center border border-slate-600"
  onPointerDown={(e) => startProtectPress(item, e)}
  onPointerUp={() => cancelProtectPress(item)}
  onPointerCancel={() => cancelProtectPress(item)}
  onPointerLeave={() => cancelProtectPress(item)}
>
                <div>
                  <div className={`font-bold text-sm ${RARITY_COLORS[item.rarity]}`}>
                    {item.name} {item.enhanceLevel>0&&`+${item.enhanceLevel}`}
                     {/* âœ… ë³´í˜¸ í‘œì‹œ */}
  {item.protected && (
    <span className="ml-2 text-[10px] bg-slate-900/60 text-yellow-200 px-1 rounded align-middle border border-yellow-400/40">
      ğŸ”’
    </span>
  )}
                    {/* âœ… ì¥ì°©(E) í‘œì‹œ */}
                    {isEquippedItem(item,player)&&(<span className="ml-2 text-[10px] bg-blue-600 text-white px-1 rounded align-middle">E</span>)}
                  </div>
                  <div className="text-[10px] text-gray-400">
                    {item.type==="weapon"&&`ATK ${item.atk??0}`}{item.type==="armor"&&`HP +${item.hp??0}`}{" | "} {item.value}G
                  </div>
                </div>
                <div className="flex gap-1">
                  {!isEnhance?(
                    <>
                      <button  onPointerDown={(e)=>e.stopPropagation()} onClick={()=>equipItem(item)} className="bg-blue-700 px-2 py-1 rounded text-[10px] hover:bg-blue-600 text-white">ì¥ì°©</button>
<button
  disabled={!!item.protected}
  onClick={(e) => { e.stopPropagation(); sellItem(item.id); }}
  className={`bg-red-900/50 px-2 py-1 rounded text-[10px] text-red-200 border border-transparent
    ${item.protected ? "opacity-40 cursor-not-allowed" : "hover:bg-red-800"}`}
>
  íŒë§¤
</button>
                    </>
                  ):(
<button
  onClick={() => {
    if ((item.enhanceLevel || 0) >= 10) startStarCatch(item); // âœ… 10ê°• ì´ìƒ ìŠ¤íƒ€ìºì¹˜
    else enhanceItem(item);                                   // âœ… 0~9ê°•ì€ ë°”ë¡œ ê°•í™”
  }}
  className="bg-yellow-700 px-2 py-1 rounded text-[10px] hover:bg-yellow-600 flex items-center gap-1 text-white"
>

  <Icons.Hammer size={10}/>
  {(() => {
    const c = getEnhanceCost(item);
    return c.stone > 0 ? `${c.gold}G + ê°•í™”ì„ ${c.stone}` : `${c.gold}G`;
  })()}
</button>
                  )}
                </div>
              </div>
            ))}
          </div>
        );
      };

      const renderForge=()=>(
         <div className="p-4 space-y-4">
    {/* âœ… í—¤ë” + ë‹«ê¸° */}
    <div className="flex items-center justify-between">
      <h2 className="text-xl font-bold text-orange-300">ğŸ”¨ ëŒ€ì¥ê°„</h2>
      <button
        onClick={() => setView("lobby")}
        className="text-xs px-3 py-2 rounded bg-slate-700 hover:bg-slate-600 border border-slate-600 text-gray-100"
      >
        ë‹«ê¸°
      </button>
    </div>

    <div className="text-sm text-gray-300">ê°™ì€ ë¬´ê¸° 10ê°œë¥¼ ì¡°í•©í•´ ìƒìœ„ ë¬´ê¸°ë¥¼ ì œì‘í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</div>
          {/* ë¬´ê¸° ì„ íƒ */}
          <div className="bg-slate-800 p-3 rounded border border-slate-600">
            <p className="text-xs text-gray-400 mb-2">ë¬´ê¸° ì„ íƒ ({forgeSelected.length}/{REQUIRED_COUNT})</p>
            {forgeCandidates.length===0&&(<div className="text-gray-500 text-sm text-center py-4">ì¡°í•© ê°€ëŠ¥í•œ ë¬´ê¸°ê°€ ì—†ìŠµë‹ˆë‹¤</div>)}
            <div className="grid grid-cols-5 gap-2">{forgeCandidates.map(item=>(
              <button key={item.id} onClick={()=>toggleForgeSelect(item)} className={`p-2 rounded border text-xs text-left transition ${forgeSelected.includes(item.id)?"bg-orange-700 border-orange-400":"bg-slate-700 border-slate-600 hover:bg-slate-600"}`}>
                <div className={`font-bold ${RARITY_COLORS[item.rarity]}`}>{item.name}</div><div className="text-gray-300">ATK {item.atk}</div>
              </button>
            ))}</div>
          </div>
          {/* ëª©í‘œ ë“±ê¸‰ ì„ íƒ */}
          <div className="bg-slate-800 p-3 rounded border border-slate-600">
            <p className="text-xs text-gray-400 mb-2">ì œì‘ ëª©í‘œ ë“±ê¸‰</p>
            <div className="grid grid-cols-3 gap-2">{["Unique","Legend","Myth"].map(rarity=>(
              <button key={rarity} onClick={()=>startForge(rarity)} className="bg-orange-700 hover:bg-orange-600 py-2 rounded text-sm font-bold">{rarity} ì œì‘</button>
            ))}</div>
          </div>
        </div>
      );

      const renderForgeMiniGame=()=>{ if(!forgeMiniGame) return null;
        return (
          <div className="fixed inset-0 bg-black/80 flex items-center justify-center z-[999]">
            <div className="bg-slate-800 border border-orange-500 rounded-xl p-6 w-80 text-center shadow-2xl space-y-4">
              {/* ì œëª© */}
              <h2 className="text-xl font-bold text-orange-400">ğŸ”¥ ë¬´ê¸° ì¡°í•©</h2>

              {/* ğŸ”° ì¤€ë¹„ ë‹¨ê³„ ì•ˆë‚´ */}
              {forgePhase==="ready"&&(<div className="text-yellow-300 text-sm animate-pulse">âš ï¸ ì ì‹œ í›„ ì¡°í•©ì´ ì‹œì‘ë©ë‹ˆë‹¤...</div>)}

              {/* âœ… ê²°ê³¼ í™”ë©´ */}
              {forgePhase==="result"&&forgeResult==="success"&&(<div className="text-green-400 font-bold text-lg">ğŸ‰ ì¡°í•© ì„±ê³µ!</div>)}
              {forgePhase==="result"&&forgeResult==="fail"&&(<div className="text-red-400 font-bold text-lg">ğŸ’¥ ì¡°í•© ì‹¤íŒ¨...</div>)}

              {/* ì„¤ëª… */}
              <p className="text-sm text-gray-300">ì œí•œ ì‹œê°„ ì•ˆì— ì•„ë˜ í‚¤ë¥¼ ìˆœì„œëŒ€ë¡œ ì…ë ¥í•˜ì„¸ìš”!</p>

              {/* =====================
                          â±ï¸ ë‚¨ì€ ì‹œê°„ ë°” UI
                      ===================== */}
              <div className="w-full h-3 bg-slate-700 rounded overflow-hidden">
                <div className={`h-full transition-all duration-75 ${((forgeMiniGame.timeLeft/10000)*100>30)?"bg-green-500":((forgeMiniGame.timeLeft/10000)*100>10)?"bg-yellow-400":"bg-red-500"}`} style={{width:`${(forgeMiniGame.timeLeft/10000)*100}%`}} />
              </div>

              {/* í‚¤ ì…ë ¥ ì‹œê°í™” */}
              <div className="flex justify-center gap-1 font-mono text-lg">
                {forgeMiniGame.keys.split("").map((char,index)=>{ const inputLen=forgeMiniGame.input.length; let style="bg-slate-700 text-gray-400";
                  // ì´ë¯¸ ë§ê²Œ ì…ë ¥í•œ ê¸€ì
                  if(index<inputLen) style="bg-green-600 text-white";
                  // í˜„ì¬ ì…ë ¥í•´ì•¼ í•  ê¸€ì
                  if(index===inputLen) style="bg-yellow-500 text-black animate-pulse";
                  // âŒ í‹€ë¦° ì…ë ¥
                  if(forgeErrorIndex===index) style="bg-red-600 text-white";
                  return (<div key={index} className={`w-8 h-10 flex items-center justify-center rounded ${style}`}>{char}</div>);
                })}
              </div>

              {/* íƒ€ì´ë¨¸ ì•ˆë‚´ */}
              <div className="text-xs text-red-400">â± ì œí•œ ì‹œê°„: 10ì´ˆ</div>
            </div>
          </div>
        );
      };

      if(view==="login"){
        return (
          <div className="flex flex-col h-screen items-center justify-center bg-slate-900 text-white p-4">
            <h1 className="text-4xl font-bold mb-8 text-blue-400 text-center">ğŸ“˜ POTATO RPG</h1>
            <div className="bg-slate-800 p-8 rounded-lg shadow-lg w-full max-w-md border border-slate-700">
              {errorMsg&&(<div className="bg-red-900/50 border border-red-500 text-red-200 p-3 rounded mb-4 text-xs">âš ï¸ {errorMsg}</div>)}
              <p className="text-center text-gray-300 mb-4 text-sm">ì´ë¦„ê³¼ ë¹„ë°€ë²ˆí˜¸ë¥¼ ì…ë ¥í•˜ë©´ ì–¸ì œë“  ì´ì–´í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</p>
              <div className="space-y-3">
                <input type="text" placeholder="ì´ë¦„ (ì˜ˆ: ì§€ë¯¼)" className="w-full p-3 bg-slate-700 rounded border border-slate-600 text-white" onChange={(e)=>setLoginName(e.target.value)} value={loginName}/>
                <input type="password" placeholder="ë¹„ë°€ë²ˆí˜¸ (ìˆ«ì 4ìë¦¬ ì¶”ì²œ)" className="w-full p-3 bg-slate-700 rounded border border-slate-600 text-white" onChange={(e)=>setLoginPw(e.target.value)} value={loginPw}/>
                <button onClick={handleLogin} className="w-full bg-blue-600 hover:bg-blue-500 text-white font-bold py-3 rounded transition shadow-lg">ê²Œì„ ì‹œì‘ / ì´ì–´í•˜ê¸°</button>
              </div>
              <div className="mt-6 text-xs text-gray-500 text-center"><p>ë°ì´í„° ì €ì¥: {db?<span className="text-green-400">ì„œë²„(Firebase)</span>:<span className="text-yellow-400">ë¡œì»¬(ë‚´ê¸°ê¸°)</span>}</p></div>
            </div>
          </div>
        );
      }

      return (
        <div className="flex flex-col h-screen bg-slate-900 text-white overflow-hidden w-full max-w-7xl mx-auto shadow-2xl relative">
          {wrongAnswerModal&&(
            <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-[999]">
              <div className="bg-slate-800 p-6 rounded-xl border border-red-500 w-80 text-center shadow-2xl">
                <h2 className="text-lg font-bold text-red-400 mb-3">âŒ ì˜¤ë‹µì…ë‹ˆë‹¤</h2>
                <p className="text-sm text-gray-200 mb-5">{wrongAnswerModal}</p>
                <button onClick={()=>setWrongAnswerModal(null)} className="bg-red-600 hover:bg-red-500 px-4 py-2 rounded text-white text-sm w-full">í™•ì¸</button>
              </div>
            </div>
          )}
          <StarCatchModal />
<QuestModal />
<TrainingSelectModal />
          {/* âœ… ìƒë‹¨ UI */}
          <div className="bg-slate-800 border-b border-slate-700 z-10 shrink-0">
            <div className="p-3 flex items-center gap-3">
              {/* âœ… ì™¼ìª½: ë ˆë²¨/ì´ë¦„/ê²½í—˜ì¹˜ */}
              <div className="flex items-center gap-3 shrink-0">
                <div className="w-10 h-10 bg-blue-600 rounded-full flex items-center justify-center font-bold shadow-md">{player.level}</div>
                <div>
                  <div className="font-bold text-sm flex items-center gap-2">{player.name}<span className="text-xs font-normal text-gray-400 bg-slate-900 px-2 rounded-full">{player.equippedWeapon?player.equippedWeapon.name:"ë§¨ì†"}</span></div>
                  <div className="w-32 h-2 bg-slate-700 rounded-full overflow-hidden mt-1"><div className="h-full bg-yellow-400" style={{width:`${(player.exp/player.maxExp)*100}%`}}/></div>
                </div>
              </div>

              {/* âœ… ê°€ìš´ë°: ë­í‚¹ (ì—¬ê¸°ê°€ â€œë¼ì›Œë„£ëŠ”â€ ì •í™•í•œ ìœ„ì¹˜) */}
              <div className="mx-4 flex-1 min-w-0 max-w-[620px]"><RankingBar db={db} appId={appId} player={player}/></div>

              {/* âœ… ì˜¤ë¥¸ìª½: HP/ê³¨ë“œ/ATK */}
              <div className="flex gap-4 text-sm font-semibold shrink-0">
                <div className="flex flex-col items-end">
                  <div className="flex items-center text-red-400"><Icons.Heart size={14} className="mr-1"/> {player.hp}/{player.maxHp}</div>
                  <div className="flex items-center text-yellow-400"><Icons.Coins size={14} className="mr-1"/> {player.gold} G</div>
                </div>
                <div className="flex items-center text-blue-300"><Icons.Sword size={14} className="mr-1"/> ATK {getTotalAtk()}</div>
              </div>
            </div>
          </div>

          <div className="flex flex-1 overflow-hidden relative">
            <div className="flex-1 flex flex-col relative overflow-y-auto bg-slate-900">
              {message&&(<div className={`absolute top-4 left-1/2 transform -translate-x-1/2 px-4 py-2 rounded-full shadow-lg z-50 animate-bounce text-sm font-bold ${message.type==="error"?"bg-red-600":"bg-green-600"}`}>{message.text}</div>)}

           {view==="lobby" && (
  <TownScene
    player={player}
    townPos={townPos}
    others={others}
    chatOpen={chatOpen}
    setChatOpen={setChatOpen}
    chatInput={chatInput}
    setChatInput={setChatInput}
    chatMessages={chatMessages}
    sendChat={sendChat}
    chatInputRef={chatInputRef}
  />
)}

{view==="tower" && TOWER_REST_FLOORS.includes(towerFloor) && (
  <div className="bg-slate-800 p-6 rounded-xl border border-emerald-600 shadow-xl mb-4">
    <div className="flex items-center justify-between">
      <h2 className="text-xl font-bold text-emerald-300">ğŸ›ï¸ íœ´ì‹ ì§€ì  - {towerFloor}ì¸µ</h2>
      <span className="text-xs text-gray-300 bg-slate-900 px-2 py-1 rounded-full">
        ì €ì¥í¬ì¸íŠ¸: {towerCheckpoint}ì¸µ
      </span>
    </div>

    <div className="text-sm text-gray-300 mt-3">
      ì ì‹œ ì‰¬ì–´ê°ˆ ìˆ˜ ìˆëŠ” ê³µê°„ì…ë‹ˆë‹¤. (ì¶”í›„ ìƒì /ê¸°ëŠ¥ ì¶”ê°€ ì˜ˆì •)
    </div>

    <div className="mt-4 flex gap-2">
      <button
        onClick={() => startTowerFloor(Math.min(TOWER_MAX_FLOOR, towerFloor+1), player, towerCheckpoint)}
        className="flex-1 bg-emerald-600 hover:bg-emerald-500 text-white font-bold py-3 rounded"
      >
        ë‹¤ìŒ ì¸µìœ¼ë¡œ
      </button>
      <button
        onClick={() => { setView("lobby"); setMonster(null); }}
        className="px-4 bg-slate-700 hover:bg-slate-600 text-white font-bold py-3 rounded"
      >
        ë¡œë¹„
      </button>
    </div>
  </div>
)}

{(view==="battle"||view==="boss"||view==="legend"||(view==="tower" && !TOWER_REST_FLOORS.includes(towerFloor))) && (
  <div className="flex flex-col h-full p-4 max-w-3xl mx-auto w-full relative">

    {/* âœ… ì „íˆ¬ í™”ë©´ ê³ ì • í€˜ìŠ¤íŠ¸ ë²„íŠ¼ (ëª¬ìŠ¤í„° ë°•ìŠ¤ ë°–) */}
    <button
      onClick={() => {
        const e = ensureDaily(player);
        if (e.changed) savePlayerData(e.player);
        setQuestOpen(true);
      }}
      className="absolute top-2 right-2 z-40 bg-slate-900/70 border border-slate-600 rounded-xl px-3 py-2 text-left shadow-xl hover:bg-slate-900/90 transition"
      title="ì˜¤ëŠ˜ì˜ í€˜ìŠ¤íŠ¸"
    >
      <div className="flex items-center gap-2">
        <Icons.Puzzle size={16} className="text-blue-300" />
        <span className="text-xs font-bold text-blue-200">ì˜¤ëŠ˜ì˜ í€˜ìŠ¤íŠ¸</span>
      </div>

      <div className="mt-1 text-[11px] text-gray-200">
        {(() => {
          const e = ensureDaily(player);
          const p = e.player;
          const q = p.dailyQuest?.missions || {};
          const pr = p.dailyQuestProgress || initDailyProgress();
          return (
            <>
              <div className="flex justify-between gap-3"><span className="text-gray-300">ì²˜ì¹˜</span><span>{pr.kills||0}/{q.kill?.target||0}</span></div>
              <div className="flex justify-between gap-3"><span className="text-gray-300">ì—°ì†</span><span>{pr.streakBest||0}/{q.streak?.target||0}</span></div>
              <div className="flex justify-between gap-3"><span className="text-gray-300">ë³´ìŠ¤</span><span>{pr.bossClears||0}/{q.boss?.target||0}</span></div>
            </>
          );
        })()}
      </div>
    </button>

{/* âœ… ëª¬ìŠ¤í„° ì˜ì—­ */}
{!(view === "tower" && TOWER_REST_FLOORS.includes(towerFloor)) && (
  <div className="flex flex-col items-center justify-center relative mb-4 min-h-[200px]">
    <div className="absolute inset-0 bg-slate-800/30 rounded-xl pointer-events-none"></div>

    {monster ? (
      <div className="z-10 text-center">
        {(() => {
          const s = monster?.image; // URL ë˜ëŠ” null
          const isImg = typeof s === "string" && /^(https?:\/\/|data:image\/)/.test(s);
          const fallback = monster?.emoji || "ğŸ¥”";

          return isImg ? (
            <img
              src={s}
              alt={monster.name}
              className="w-[240px] h-[240px] object-contain mx-auto mb-4 drop-shadow-2xl"
            />
          ) : (
            <div className="text-8xl mb-4 filter drop-shadow-2xl animate-bounce-slow">
              {fallback}
            </div>
          );
        })()}

        <div className="text-2xl font-bold text-red-300 mb-1">{monster.name}</div>

        {/* ì´í•˜ HPë°” ë“± ê¸°ì¡´ ì½”ë“œ ê³„ì† */}
      </div>
    ) : (
      <div className="text-center z-10 text-gray-400 flex flex-col items-center gap-2">
        <Icons.RefreshCw className="animate-spin text-blue-400" size={32}/>
        <span>{isRespawning ? "ë‹¤ìŒ ëª¬ìŠ¤í„° ì°¾ëŠ” ì¤‘..." : "íƒìƒ‰ ì¤‘..."}</span>
      </div>
    )}
  </div>
)}

    {/* âœ… ì „íˆ¬ ë¡œê·¸ */}
    <div className="h-20 overflow-y-auto bg-black/40 rounded p-3 text-sm text-gray-300 mb-4 font-mono shadow-inner border border-slate-700/50">
      {battleLog.map((log,i)=><div key={i} className="mb-1 border-b border-white/5 pb-1">{log}</div>)}
    </div>

    {/* âœ… ë¬¸ì œ */}
    {currentQuestion && monster && (
      <div className="bg-slate-800 p-6 rounded-xl border border-slate-600 shadow-xl">
        <span className="text-xs bg-blue-900 text-blue-200 px-3 py-1 rounded-full font-bold mb-3 inline-block">
          {currentQuestion.subject}
        </span>

        <div className="text-xl font-bold mb-6 leading-relaxed">
          {String(currentQuestion.question).startsWith("http")
            ? <img src={currentQuestion.question} alt="ë¬¸ì œ ì´ë¯¸ì§€" className="max-w-full h-auto rounded"/>
            : currentQuestion.question}
        </div>

        <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
          {currentQuestion.options.map((opt,idx)=>(
            <button
              key={idx}
              onClick={()=>handleAnswer(idx)}
              className="bg-slate-700 hover:bg-blue-600 p-4 rounded-lg text-left transition duration-200 border border-slate-600 hover:border-blue-400 font-medium"
            >
              <span className="text-blue-300 mr-2 font-bold">{idx+1}.</span>
              {String(opt).startsWith("http")
                ? <img src={opt} alt={`ë³´ê¸° ${idx+1}`} className="inline-block max-h-20 rounded"/>
                : opt}
            </button>
          ))}
        </div>
      </div>
    )}

    {/* âœ… ë„ë§ê°€ê¸° */}
    <button
      onClick={()=>{ setView("lobby"); setMonster(null); }}
      className="mt-6 text-gray-500 hover:text-white flex items-center justify-center gap-2 py-2 w-full md:w-auto mx-auto"
    >
      <Icons.LogOut size={16}/> ë„ë§ê°€ê¸°
    </button>
  </div>
)}	

              {(view==="inventory"||view==="enhance")&&(
                <div className="p-4 h-full overflow-y-auto md:hidden">
                  <h2 className="text-xl font-bold mb-4 flex items-center gap-2 pb-2 border-b border-slate-700">{view==="inventory"?"ì¸ë²¤í† ë¦¬":"ëŒ€ì¥ê°„"}</h2>
                  {renderInventory(view==="enhance")}
                </div>
              )}

              {view==="forge"&&(
                <div className="p-4 h-full overflow-y-auto relative">
                  {renderForge()}
                  {/* ğŸ”½ ë¯¸ë‹ˆê²Œì„ UI ì˜¤ë²„ë ˆì´ */}
                  {renderForgeMiniGame()}
                </div>
              )}
            </div>

            <div className="hidden md:flex w-80 bg-slate-800 border-l border-slate-700 flex-col shrink-0">
              <div className="flex text-sm font-bold border-b border-slate-700">
              <div className="flex text-sm font-bold border-b border-slate-700">
  <button
    className={`flex-1 h-8 px-10 flex items-center justify-center gap-2 ${
      sideTab === "equip" ? "bg-slate-800 text-blue-400" : "bg-slate-700 text-gray-400"
    }`}
    onClick={() => setSideTab("equip")}
  >
    <Icons.Sword size={16}/> ì¥ë¹„
  </button>

  <button
    className={`flex-1 h-8 px-10 flex items-center justify-center gap-2 ${
      sideTab === "enhance" ? "bg-slate-800 text-yellow-400" : "bg-slate-700 text-gray-400"
    }`}
    onClick={() => setSideTab("enhance")}
  >
    <Icons.Hammer size={16}/> ê°•í™”
  </button>
</div>

              </div>
<div className="flex-1 overflow-y-auto p-3">{renderInventory(sideTab === "enhance")}</div>
            </div>
          </div>

          <div className="md:hidden bg-slate-800 p-2 flex justify-around border-t border-slate-700 z-10 shrink-0">
            <button onClick={()=>setView("lobby")} className={`p-2 rounded flex flex-col items-center gap-1 ${view==="lobby"?"text-blue-400":"text-gray-400"}`}><Icons.Menu size={20}/><span className="text-[10px]">ë¡œë¹„</span></button>
            <button onClick={()=>setView("inventory")} className={`p-2 rounded flex flex-col items-center gap-1 ${view==="inventory"?"text-blue-400":"text-gray-400"}`}><Icons.Sword size={20}/><span className="text-[10px]">ê°€ë°©</span></button>
            <button onClick={()=>setView("enhance")} className={`p-2 rounded flex flex-col items-center gap-1 ${view==="enhance"?"text-blue-400":"text-gray-400"}`}><Icons.Hammer size={20}/><span className="text-[10px]">ê°•í™”</span></button>
          </div>
        </div>
      );
    }

    const root=ReactDOM.createRoot(document.getElementById("root"));
    // ErrorBoundaryë¡œ App ê°ì‹¸ê¸°
    root.render(<ErrorBoundary><App/></ErrorBoundary>);
  </script>
</body>
</html>
